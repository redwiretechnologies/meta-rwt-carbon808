From 897d7e1ac0bd84def8bc7fc942a2ecbec6931346 Mon Sep 17 00:00:00 2001
From: OpenEmbedded <tflynn@redwiretechnology.com>
Date: Fri, 2 Aug 2024 19:16:51 -0400
Subject: [PATCH] adding pac193x patch

---
 drivers/iio/power/pac193x.c | 2846 +++++++++++++++++++----------------
 1 file changed, 1523 insertions(+), 1323 deletions(-)

diff --git a/drivers/iio/power/pac193x.c b/drivers/iio/power/pac193x.c
index 0de903ecc5f3..f51118ee2eec 100644
--- a/drivers/iio/power/pac193x.c
+++ b/drivers/iio/power/pac193x.c
@@ -1,211 +1,279 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
- * IIO driver for PAC193x series chips
+ * IIO driver for PAC1934 Multi-Channel DC Power/Energy Monitor
  *
- * Copyright (C) 2017 Microchip Technology Inc.
+ * Copyright (C) 2017-2023 Microchip Technology Inc. and its subsidiaries
  *
- * Author: Bogdan Bolocan http://www.microchip.com/support
+ * Author: Bogdan Bolocan <bogdan.bolocan@microchip.com>
+ * Author: Victor Tudose
+ * Author: Marius Cristea <marius.cristea@microchip.com>
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ * Datasheet for PAC1931, PAC1932, PAC1933 and PAC1934 can be found here:
+ * https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/PAC1931-Family-Data-Sheet-DS20005850E.pdf
  *
  */
 
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/err.h>
-#include <linux/slab.h>
-#include <linux/jiffies.h>
+#include <linux/acpi.h>
+#include <linux/bitfield.h>
 #include <linux/delay.h>
-#include <linux/timer.h>
-#include <linux/util_macros.h>
-#include <linux/kthread.h>
-
+#include <linux/err.h>
 #include <linux/i2c.h>
-
-#include <linux/acpi.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
-#include <linux/iio/buffer.h>
-#include <linux/iio/kfifo_buf.h>
-#define PAC193X_MAX_RFSH_LIMIT						60000
-/*(17 * 60 * 1000) //around 17 minutes@1024 sps */
-#define PAC193X_MIN_POLLING_TIME					50
-/* 50msec is the timeout for validity of the cached registers */
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <asm/unaligned.h>
 
-#define SHUNT_UOHMS_DEFAULT						100000
+/*
+ * maximum accumulation time should be (17 * 60 * 1000) around 17 minutes@1024 sps
+ * till PAC193X accumulation registers starts to saturate
+ */
+#define PAC193X_MAX_RFSH_LIMIT_MS		60000
+/* 50msec is the timeout for validity of the cached registers */
+#define PAC193X_MIN_POLLING_TIME_MS		50
+/*
+ * 1000usec is the minimum wait time for normal conversions when sample
+ * rate doesn't change
+ */
+#define PAC193X_MIN_UPDATE_WAIT_TIME_US		1000
 
-#define PAC193X_VOLTAGE_MILLIVOLTS_MAX					32000
+#define SHUNT_UOHMS_DEFAULT			100000
 /* 32000mV */
-#define PAC193X_VOLTAGE_U_RES						16
+#define PAC193X_VOLTAGE_MILLIVOLTS_MAX		32000
 /* voltage bits resolution when set for unsigned values */
-#define PAC193X_VOLTAGE_S_RES						15
+#define PAC193X_VOLTAGE_U_RES			16
 /* voltage bits resolution when set for signed values */
-
-#define PAC193X_VSENSE_MILLIVOLTS_MAX					100
+#define PAC193X_VOLTAGE_S_RES			15
 /* 100mV maximum for current shunts */
-#define PAC193X_CURRENT_U_RES						16
+#define PAC193X_VSENSE_MILLIVOLTS_MAX		100
 /* voltage bits resolution when set for unsigned values */
-#define PAC193X_CURRENT_S_RES						15
+#define PAC193X_CURRENT_U_RES			16
 /* voltage bits resolution when set for signed values */
+#define PAC193X_CURRENT_S_RES			15
 
-#define PAC193X_POWER_U_RES						28
 /* power resolution is 28 bits when unsigned */
-#define PAC193X_POWER_S_RES						27
+#define PAC193X_POWER_U_RES			28
 /* power resolution is 27 bits when signed */
+#define PAC193X_POWER_S_RES			27
 
-#define PAC193X_ENERGY_U_RES						48
 /* energy accumulation is 48 bits long */
-#define PAC193X_ENERGY_S_RES						47
-#define PAC193X_ENERGY_SHIFT_MAIN_VAL					32
+#define PAC193X_ENERGY_U_RES			48
 
-#define PAC193X_MAX_NUM_CHANNELS					4
-#define PAC193X_MEAS_REG_SNAPSHOT_LEN					76
-#define PAC193X_CTRL_REG_SNAPSHOT_LEN					12
+#define PAC193X_ENERGY_S_RES			47
 
-#define PAC193x_CHIP_AVG_NUMBER						8
+#define BIT_INDEX_31				31
 
-#define PAC193x_MIN_UPDATE_WAIT_TIME					1000
-/* 1000usec is the minimum wait time for normal conversions when sample
- * rate doesn't change
+/*
+ * max signed value that can be stored on 32 bits and 8 digits fractional value
+ * (2^31 - 1) * 10^8 + 99999999
+ */
+#define PAC_193X_MAX_POWER_ACC			214748364799999999LL
+/*
+ * min signed value that can be stored on 32 bits and 8 digits fractional value
+ * -(2^31) * 10^8 - 99999999
  */
-#define PAC193x_DEFAULT_CHIP_SAMP_SPEED					1024
-#define PAC193x_SAMP_1024SPS						0
-/* this sampling speed is represented as a 0b00 value */
-#define PAC193x_SAMP_256SPS						1
-#define PAC193x_SAMP_64SPS						2
-#define PAC193x_SAMP_8SPS						3
+#define PAC_193X_MIN_POWER_ACC			-214748364899999999LL
+
+/* maximum value that device can measure - 32 V * 0.1 V */
+#define PAC193X_PRODUCT_VOLTAGE_PV_FSR		3200000000000UL
+
+#define PAC193X_MAX_NUM_CHANNELS		4
+#define PAC1931_NUM_CHANNELS			1
+#define PAC1932_NUM_CHANNELS			2
+#define PAC1933_NUM_CHANNELS			3
+#define PAC1934_NUM_CHANNELS			4
+#define PAC193X_CH_1				0
+#define PAC193X_CH_2				1
+#define PAC193X_CH_3				2
+#define PAC193X_CH_4				3
+#define PAC193X_MEAS_REG_LEN			76
+#define PAC193X_CTRL_REG_LEN			12
+
+#define PAC193X_DEFAULT_CHIP_SAMP_SPEED		1024
 
 /* I2C address map */
-#define PAC193X_REFRESH_REG						0x00
-#define PAC193X_CTRL_REG						0x01
-#define PAC193X_REFRESH_V_REG						0x1F
-#define PAC193X_ACC_COUNT_REG						0x02
-#define PAC193X_CTRL_STAT_REGS_ADDR					0x1C
-#define PAC193X_PID_REG_ADDR						0xFD
-
-#define PAC193X_VPOWER_ACC_0_ADDR					0x03
-#define PAC193X_VPOWER_ACC_1_ADDR	(PAC193X_VPOWER_ACC_0_ADDR + 1)
-#define PAC193X_VPOWER_ACC_2_ADDR					0x05
-#define PAC193X_VPOWER_ACC_3_ADDR					0x06
-#define PAC193X_VBUS_0_ADDR						0x07
-#define PAC193X_VBUS_1_ADDR						0x08
-#define PAC193X_VBUS_2_ADDR						0x09
-#define PAC193X_VBUS_3_ADDR						0x0A
-#define PAC193X_VSENSE_0_ADDR						0x0B
-#define PAC193X_VSENSE_1_ADDR						0x0C
-#define PAC193X_VSENSE_2_ADDR						0x0D
-#define PAC193X_VSENSE_3_ADDR						0x0E
-#define PAC193X_VBUS_AVG_0_ADDR						0x0F
-#define PAC193X_VBUS_AVG_1_ADDR						0x10
-#define PAC193X_VBUS_AVG_2_ADDR						0x11
-#define PAC193X_VBUS_AVG_3_ADDR						0x12
-#define PAC193X_VSENSE_AVG_0_ADDR					0x13
-#define PAC193X_VSENSE_AVG_1_ADDR					0x14
-#define PAC193X_VSENSE_AVG_2_ADDR					0x15
-#define PAC193X_VSENSE_AVG_3_ADDR					0x16
-#define PAC193X_VPOWER_0_ADDR						0x17
-#define PAC193X_VPOWER_1_ADDR						0x18
-#define PAC193X_VPOWER_2_ADDR						0x19
-#define PAC193X_VPOWER_3_ADDR						0x1A
-
-/* these indexes are exactly describing the element order within a single
- * PAC193x phys channel IIO channel descriptor; see the static const struct
+#define PAC193X_REFRESH_REG_ADDR		0x00
+#define PAC193X_CTRL_REG_ADDR			0x01
+#define PAC193X_ACC_COUNT_REG_ADDR		0x02
+#define PAC193X_VPOWER_ACC_1_ADDR		0x03
+#define PAC193X_VPOWER_ACC_2_ADDR		0x04
+#define PAC193X_VPOWER_ACC_3_ADDR		0x05
+#define PAC193X_VPOWER_ACC_4_ADDR		0x06
+#define PAC193X_VBUS_1_ADDR			0x07
+#define PAC193X_VBUS_2_ADDR			0x08
+#define PAC193X_VBUS_3_ADDR			0x09
+#define PAC193X_VBUS_4_ADDR			0x0A
+#define PAC193X_VSENSE_1_ADDR			0x0B
+#define PAC193X_VSENSE_2_ADDR			0x0C
+#define PAC193X_VSENSE_3_ADDR			0x0D
+#define PAC193X_VSENSE_4_ADDR			0x0E
+#define PAC193X_VBUS_AVG_1_ADDR			0x0F
+#define PAC193X_VBUS_AVG_2_ADDR			0x10
+#define PAC193X_VBUS_AVG_3_ADDR			0x11
+#define PAC193X_VBUS_AVG_4_ADDR			0x12
+#define PAC193X_VSENSE_AVG_1_ADDR		0x13
+#define PAC193X_VSENSE_AVG_2_ADDR		0x14
+#define PAC193X_VSENSE_AVG_3_ADDR		0x15
+#define PAC193X_VSENSE_AVG_4_ADDR		0x16
+#define PAC193X_VPOWER_1_ADDR			0x17
+#define PAC193X_VPOWER_2_ADDR			0x18
+#define PAC193X_VPOWER_3_ADDR			0x19
+#define PAC193X_VPOWER_4_ADDR			0x1A
+#define PAC193X_REFRESH_V_REG_ADDR		0x1F
+#define PAC193X_CTRL_STAT_REGS_ADDR		0x1C
+#define PAC193X_PID_REG_ADDR			0xFD
+#define PAC193X_MID_REG_ADDR			0xFE
+#define PAC193X_RID_REG_ADDR			0xFF
+
+/* PRODUCT ID REGISTER + MANUFACTURER ID REGISTER + REVISION ID REGISTER */
+#define PAC193X_ID_REG_LEN			0x03
+#define PAC193X_PID_IDX				0
+#define PAC193X_MID_IDX				1
+#define PAC193X_RID_IDX				2
+
+#define PAC193X_ACPI_ARG_COUNT			4
+#define PAC193X_ACPI_GET_NAMES_AND_MOHMS_VALS	1
+#define PAC193X_ACPI_GET_UOHMS_VALS		2
+#define PAC193X_ACPI_GET_BIPOLAR_SETTINGS	4
+#define PAC193X_ACPI_GET_SAMP			5
+
+#define PAC193X_SAMPLE_RATE_SHIFT		6
+
+/*
+ * these indexes are exactly describing the element order within a single
+ * PAC193X phys channel IIO channel descriptor; see the static const struct
  * iio_chan_spec pac193x_single_channel[] declaration
  */
-#define IIO_EN								0
-#define IIO_POW								1
-#define IIO_VOLT							2
-#define IIO_CRT								3
-#define IIO_VOLTAVG							4
-#define IIO_CRTAVG							5
-
-#define PAC193X_ACC_REG_LEN						3
-#define PAC193X_VPOWER_ACC_REG_LEN					6
-#define PAC193X_VBUS_SENSE_REG_LEN					2
-#define PAC193X_VPOWER_REG_LEN						4
-
-/* relative offsets when using multi-byte reads/writes even though these
+#define IIO_EN					0
+#define IIO_POW					1
+#define IIO_VOLT				2
+#define IIO_CRT					3
+#define IIO_VOLTAVG				4
+#define IIO_CRTAVG				5
+
+#define PAC193X_VBUS_SENSE_REG_LEN		2
+#define PAC193X_ACC_REG_LEN			3
+#define PAC193X_VPOWER_REG_LEN			4
+#define PAC193X_VPOWER_ACC_REG_LEN		6
+#define PAC193X_MAX_REGISTER_LENGTH		6
+
+#define PAC193X_CUSTOM_ATTR_FOR_CHANNEL		2
+#define PAC193X_SHARED_DEVATTRS_COUNT		1
+
+/*
+ * relative offsets when using multi-byte reads/writes even though these
  * bytes are read one after the other, they are not at adjacent memory
  * locations within the I2C memory map. The chip can skip some addresses
  */
-#define PAC193X_CHANNEL_DIS_REG_OFF					0
-#define PAC193X_NEG_PWR_REG_OFF						1
-/* when reading/writing multiple bytes from offset PAC193X_CHANNEL_DIS_REG_OFF,
+#define PAC193X_CHANNEL_DIS_REG_OFF		0
+#define PAC193X_NEG_PWR_REG_OFF			1
+
+/*
+ * when reading/writing multiple bytes from offset PAC193X_CHANNEL_DIS_REG_OFF,
  * the chip jumps over the 0x1E (REFRESH_G) and 0x1F (REFRESH_V) offsets
  */
-#define PAC193X_SLOW_REG_OFF						2
-#define PAC193X_CTRL_ACT_REG_OFF					3
-#define PAC193X_CHANNEL_DIS_ACT_REG_OFF					4
-#define PAC193X_NEG_PWR_ACT_REG_OFF					5
-#define PAC193X_CTRL_LAT_REG_OFF					6
-#define PAC193X_CHANNEL_DIS_LAT_REG_OFF					7
-#define PAC193X_NEG_PWR_LAT_REG_OFF					8
-#define PAC193X_PID_REG_OFF						9
-#define PAC193X_MID_REG_OFF						10
-#define PAC193X_REV_REG_OFF						11
-
-#define PAC193X_CTRL_STATUS_INFO_LEN		(PAC193X_REV_REG_OFF + 1)
-
-#define PAC193X_CH_DIS_NOSKIP_VAL					0x02
-
-#define PAC193X_MID							0x5D
-#define PAC1934_PID							0x5B
-#define PAC1932_PID							0x5C
-#define PAC1931_PID							0x5D
-
-#define CTRL_REG(samp, sleep, sing, al_p, al_cc, ovf_al) \
-						((((u8)samp & 0x03) << 6) |\
-						(((u8)sleep & 0x01) << 5) |\
-						(((u8)sing & 0x01) << 4) |\
-						(((u8)al_p & 0x01) << 3) |\
-						(((u8)al_cc & 0x01) << 2) |\
-						(((u8)ovf_al & 0x01) << 1))
-
-#define CHANNEL_DIS_REG(ch1_on, ch2_on, ch3_on, ch4_on, \
-			smb_tout, bycount, skip)\
-						((ch1_on ? 0 : 0x80) | \
-						(ch2_on ? 0 : 0x40) | \
-						(ch3_on ? 0 : 0x20) | \
-						(ch4_on ? 0 : 0x10) | \
-					(((u8)smb_tout & 0x01) << 3) | \
-					(((u8)bycount & 0x01) << 2) | \
-						(skip ? 0 : 0x02))
-
-#define NEG_PWR_REG(ch1_bidi, ch2_bidi, ch3_bidi, ch4_bidi, \
-			ch1_bidv, ch2_bidv, ch3_bidv, ch4_bidv)\
-						((ch1_bidi ? 0x80 : 0) | \
-						(ch2_bidi ? 0x40 : 0) | \
-						(ch3_bidi ? 0x20 : 0) | \
-						(ch4_bidi ? 0x10 : 0) | \
-						(ch1_bidv ? 0x08 : 0) | \
-						(ch2_bidv ? 0x04 : 0) | \
-						(ch3_bidv ? 0x02 : 0) | \
-						(ch4_bidv ? 0x01 : 0))
+#define PAC193X_SLOW_REG_OFF			2
+#define PAC193X_CTRL_ACT_REG_OFF		3
+#define PAC193X_CHANNEL_DIS_ACT_REG_OFF		4
+#define PAC193X_NEG_PWR_ACT_REG_OFF		5
+#define PAC193X_CTRL_LAT_REG_OFF		6
+#define PAC193X_CHANNEL_DIS_LAT_REG_OFF		7
+#define PAC193X_NEG_PWR_LAT_REG_OFF		8
+#define PAC193X_PID_REG_OFF			9
+#define PAC193X_MID_REG_OFF			10
+#define PAC193X_REV_REG_OFF			11
+#define PAC193X_CTRL_STATUS_INFO_LEN		12
+
+#define PAC193X_MID				0x5D
+#define PAC1934_PID				0x5B
+#define PAC1933_PID				0x5A
+#define PAC1932_PID				0x59
+#define PAC1931_PID				0x58
+
+/* Scale constant = (10^3 * 3.2 * 10^9 / 2^28) for mili Watt-second */
+#define PAC193X_SCALE_CONSTANT			11921
+
+#define PAC193X_MAX_VPOWER_RSHIFTED_BY_28B	11921
+#define PAC193X_MAX_VSENSE_RSHIFTED_BY_16B	1525
+
+#define PAC193X_DEV_ATTR(name) (&iio_dev_attr_##name.dev_attr.attr)
+
+#define PAC193X_CRTL_SAMPLE_RATE_MASK	GENMASK(7, 6)
+#define PAC193X_CRTL_SAMPLE_RATE_SET(x)	((u8)FIELD_PREP(PAC193X_CRTL_SAMPLE_RATE_MASK, (x)))
+#define PAC193X_CHAN_SLEEP_MASK		BIT(5)
+#define PAC193X_CHAN_SLEEP_SET		BIT(5)
+#define PAC193X_CHAN_SINLE_MASK		BIT(4)
+#define PAC193X_CHAN_SINLE_SHOT_SET	BIT(4)
+#define PAC193X_CHAN_ALERT_MASK		BIT(3)
+#define PAC193X_CHAN_ALERT_EN		BIT(3)
+#define PAC193X_CHAN_ALERT_CC_MASK	BIT(2)
+#define PAC193X_CHAN_ALERT_CC_EN	BIT(2)
+#define PAC193X_CHAN_OVF_ALERT_MASK	BIT(1)
+#define PAC193X_CHAN_OVF_ALERT_EN	BIT(1)
+#define PAC193X_CHAN_OVF_MASK		BIT(0)
+
+#define PAC193X_CHAN_DIS_CH1_OFF_MASK	BIT(7)
+#define PAC193X_CHAN_DIS_CH1_OFF(x)	((u8)FIELD_PREP(PAC193X_CHAN_DIS_CH1_OFF_MASK, !(x)))
+#define PAC193X_CHAN_DIS_CH2_OFF_MASK	BIT(6)
+#define PAC193X_CHAN_DIS_CH2_OFF(x)	((u8)FIELD_PREP(PAC193X_CHAN_DIS_CH2_OFF_MASK, !(x)))
+#define PAC193X_CHAN_DIS_CH3_OFF_MASK	BIT(5)
+#define PAC193X_CHAN_DIS_CH3_OFF(x)	((u8)FIELD_PREP(PAC193X_CHAN_DIS_CH3_OFF_MASK, !(x)))
+#define PAC193X_CHAN_DIS_CH4_OFF_MASK	BIT(4)
+#define PAC193X_CHAN_DIS_CH4_OFF(x)	((u8)FIELD_PREP(PAC193X_CHAN_DIS_CH4_OFF_MASK, !(x)))
+#define PAC193X_SMBUS_TIMEOUT_MASK	BIT(3)
+#define PAC193X_SMBUS_TIMEOUT_EN(x)	FIELD_PREP(PAC193X_SMBUS_TIMEOUT_MASK, x)
+#define PAC193X_SMBUS_BYTECOUNT_MASK	BIT(2)
+#define PAC193X_SMBUS_BYTECOUNT_EN(x)	FIELD_PREP(PAC193X_SMBUS_BYTECOUNT_MASK, x)
+#define PAC193X_SMBUS_NO_SKIP_MASK	BIT(1)
+#define PAC193X_SMBUS_NO_SKIP_EN(x)	FIELD_PREP(PAC193X_SMBUS_NO_SKIP_MASK, x)
+
+#define PAC193X_NEG_PWR_CH1_BIDI_MASK	BIT(7)
+#define PAC193X_NEG_PWR_CH1_BIDI(x)	((u8)FIELD_PREP(PAC193X_NEG_PWR_CH1_BIDI_MASK, (x)))
+#define PAC193X_NEG_PWR_CH2_BIDI_MASK	BIT(6)
+#define PAC193X_NEG_PWR_CH2_BIDI(x)	((u8)FIELD_PREP(PAC193X_NEG_PWR_CH2_BIDI_MASK, (x)))
+#define PAC193X_NEG_PWR_CH3_BIDI_MASK	BIT(5)
+#define PAC193X_NEG_PWR_CH3_BIDI(x)	((u8)FIELD_PREP(PAC193X_NEG_PWR_CH3_BIDI_MASK, (x)))
+#define PAC193X_NEG_PWR_CH4_BIDI_MASK	BIT(4)
+#define PAC193X_NEG_PWR_CH4_BIDI(x)	((u8)FIELD_PREP(PAC193X_NEG_PWR_CH4_BIDI_MASK, (x)))
+#define PAC193X_NEG_PWR_CH1_BIDV_MASK	BIT(3)
+#define PAC193X_NEG_PWR_CH1_BIDV(x)	((u8)FIELD_PREP(PAC193X_NEG_PWR_CH1_BIDV_MASK, (x)))
+#define PAC193X_NEG_PWR_CH2_BIDV_MASK	BIT(2)
+#define PAC193X_NEG_PWR_CH2_BIDV(x)	((u8)FIELD_PREP(PAC193X_NEG_PWR_CH2_BIDV_MASK, (x)))
+#define PAC193X_NEG_PWR_CH3_BIDV_MASK	BIT(1)
+#define PAC193X_NEG_PWR_CH3_BIDV(x)	((u8)FIELD_PREP(PAC193X_NEG_PWR_CH3_BIDV_MASK, (x)))
+#define PAC193X_NEG_PWR_CH4_BIDV_MASK	BIT(0)
+#define PAC193X_NEG_PWR_CH4_BIDV(x)	((u8)FIELD_PREP(PAC193X_NEG_PWR_CH4_BIDV_MASK, (x)))
+
+/*
+ * Universal Unique Identifier (UUID),
+ * 033771E0-1705-47B4-9535-D1BBE14D9A09, is
+ * reserved to Microchip for the PAC193X and must not be changed
+ */
+#define PAC193X_DSM_UUID		"033771E0-1705-47B4-9535-D1BBE14D9A09"
 
 enum pac193x_ids {
-	pac1934,
-	pac1932,
-	pac1931
+	PAC1931,
+	PAC1932,
+	PAC1933,
+	PAC1934
 };
 
+enum pac193x_samps {
+	PAC193X_SAMP_1024SPS,
+	PAC193X_SAMP_256SPS,
+	PAC193X_SAMP_64SPS,
+	PAC193X_SAMP_8SPS
+};
+
+/**
+ * struct pac193x_features - features of a pac193x instance
+ * @phys_channels: number of physical channels supported by the chip
+ * @prod_id: product ID
+ */
 struct pac193x_features {
-	u8 phys_channels;/*number of physical channels supported by the chip */
-	u8 prod_id; /*product ID*/
+	u8 phys_channels;
+	u8 prod_id;
 };
 
 struct samp_rate_mapping {
@@ -213,37 +281,48 @@ struct samp_rate_mapping {
 	u8 shift2value;
 };
 
-static const u16 samp_rate_map_tbl[] = {
-	[PAC193x_SAMP_1024SPS] = 1024,
-	[PAC193x_SAMP_256SPS] = 256,
-	[PAC193x_SAMP_64SPS] = 64,
-	[PAC193x_SAMP_8SPS] = 8,
+static const unsigned int samp_rate_map_tbl[] = {
+	[PAC193X_SAMP_1024SPS] = 1024,
+	[PAC193X_SAMP_256SPS] = 256,
+	[PAC193X_SAMP_64SPS] = 64,
+	[PAC193X_SAMP_8SPS] = 8,
 };
 
 static const struct pac193x_features pac193x_chip_config[] = {
-	[pac1934] = {
-		.phys_channels = PAC193X_MAX_NUM_CHANNELS,
-		.prod_id = PAC1934_PID,
+	[PAC1931] = {
+		.phys_channels = 1,
+		.prod_id = PAC1931_PID,
 	},
-	[pac1932] = {
-		.phys_channels = PAC193X_MAX_NUM_CHANNELS >> 1,
+	[PAC1932] = {
+		.phys_channels = 2,
 		.prod_id = PAC1932_PID,
 	},
-	[pac1931] = {
-		.phys_channels = PAC193X_MAX_NUM_CHANNELS >> 2,
-		.prod_id = PAC1931_PID,
+	[PAC1933] = {
+		.phys_channels = 3,
+		.prod_id = PAC1933_PID,
+	},
+	[PAC1934] = {
+		.phys_channels = 4,
+		.prod_id = PAC1934_PID,
 	},
 };
 
+/**
+ * struct reg_data - data from the registers
+ * @meas_regs: snapshot of raw measurements registers
+ * @ctrl_regs: snapshot of control registers
+ * @energy_sec_acc: snapshot of energy values
+ * @vpower_acc: accumulated vpower values
+ * @vpower: snapshot of vpower registers
+ * @vbus: snapshot of vbus registers
+ * @vbus_avg: averages of vbus registers
+ * @vsense: snapshot of vsense registers
+ * @vsense_avg: averages of vsense registers
+ * @num_enabled_channels: count of how many chip channels are currently enabled
+ */
 struct reg_data {
-	/* these fields keep track of chip's runtime configuration */
-	bool	active_channels[PAC193X_MAX_NUM_CHANNELS];
-	bool	bi_dir[PAC193X_MAX_NUM_CHANNELS];
-
-	/* these variables keep the chip values as read from it - snapshot */
-	u8	meas_regs[PAC193X_MEAS_REG_SNAPSHOT_LEN];
-	u8	ctrl_regs[PAC193X_CTRL_REG_SNAPSHOT_LEN];
-	u32	acc_count;
+	u8	meas_regs[PAC193X_MEAS_REG_LEN];
+	u8	ctrl_regs[PAC193X_CTRL_REG_LEN];
 	s64	energy_sec_acc[PAC193X_MAX_NUM_CHANNELS];
 	s64	vpower_acc[PAC193X_MAX_NUM_CHANNELS];
 	s32	vpower[PAC193X_MAX_NUM_CHANNELS];
@@ -251,1420 +330,1541 @@ struct reg_data {
 	s32	vbus_avg[PAC193X_MAX_NUM_CHANNELS];
 	s32	vsense[PAC193X_MAX_NUM_CHANNELS];
 	s32	vsense_avg[PAC193X_MAX_NUM_CHANNELS];
-	unsigned long jiffies_tstamp;
-	/* this variable stores the current sampling speed */
-	u8	crt_samp_speed_bitfield;
-	/* this variable keeps the count of how many chip
-	 * channels are currently enabled
-	 */
 	u8	num_enabled_channels;
 };
+
+/**
+ * struct pac193x_chip_info - information about the chip
+ * @client: the i2c-client attached to the device
+ * @lock: lock used by the chip's mutex
+ * @work_chip_rfsh: work queue used for refresh commands
+ * @phys_channels: phys channels count
+ * @active_channels: array of values, true means that channel is active
+ * @bi_dir: array of bools, true means that channel is bidirectional
+ * @chip_variant: chip variant
+ * @chip_revision: chip revision
+ * @shunts: shunts
+ * @chip_reg_data: chip reg data
+ * @sample_rate_value: sampling frequency
+ * @channel_names: channel names
+ * @pac193x_info: pac193x_info
+ * @crt_samp_spd_bitfield:the current sampling speed
+ * @jiffies_tstamp: chip's uptime
+ */
 struct pac193x_chip_info {
-	const struct iio_chan_spec	*channels;
-	const struct iio_info		*indio_info;
-	struct i2c_client		*client;
-	struct mutex			lock;
-
-	struct timer_list		tmr_forced_update;
-	/* to be used to now when will be the chip read timeout */
-	u32				forced_reads_triggered;
-	u32				rearm_force_read;
-
-	/* workqueue for periodic chip readings to prevent saturation */
-	struct workqueue_struct		*wq_chip;
-	struct work_struct		work_chip_rfsh;
-
-	u8				phys_channels;
-	u8				chip_variant;
-	u8				chip_revision;
-
-	u32				shunts[PAC193X_MAX_NUM_CHANNELS];
-	struct reg_data			chip_reg_data;
-	unsigned int			avg_num;
-	u32				sample_rate_value;
+	struct i2c_client	*client;
+	struct mutex		lock; /* lock to prevent concurrent reads/writes */
+	struct delayed_work	work_chip_rfsh;
+	u8			phys_channels;
+	bool			active_channels[PAC193X_MAX_NUM_CHANNELS];
+	bool			bi_dir[PAC193X_MAX_NUM_CHANNELS];
+	u8			chip_variant;
+	u8			chip_revision;
+	u32			shunts[PAC193X_MAX_NUM_CHANNELS];
+	struct reg_data		chip_reg_data;
+	s32			sample_rate_value;
+	char			*channel_names[PAC193X_MAX_NUM_CHANNELS];
+	struct iio_info		pac193x_info;
+	u8			crt_samp_spd_bitfield;
+	unsigned long		jiffies_tstamp;
 };
 
-#define to_pac193x_chip_info(d) container_of(d, struct pac193x_chip_info, \
-						work_chip_rfsh)
-/* macros to extract the parameters */
-#define mACC_COUNT(addr)		(((u32)(*(u8 *)(addr + 0)) << 16) | \
-					((u32)(*(u8 *)(addr + 1)) << 8) | \
-					((u32)(*(u8 *)(addr + 2)) << 0))
-
-#define mVPOWER_ACCu(addr)		(((u64)(*(u8 *)(addr + 0)) << 40) | \
-					((u64)(*(u8 *)(addr + 1)) << 32) | \
-					((u64)(*(u8 *)(addr + 2)) << 24) | \
-					((u64)(*(u8 *)(addr + 3)) << 16) | \
-					((u64)(*(u8 *)(addr + 4)) << 8) | \
-					((u64)(*(u8 *)(addr + 5)) << 0))
-
-#define mVPOWER_ACCs(addr)		sign_extend64(mVPOWER_ACCu(addr), 47)
+#define TO_PAC193X_CHIP_INFO(d) container_of(d, struct pac193x_chip_info, work_chip_rfsh)
 
-#define mVPOWERu(addr)			(((u32)(*(u8 *)(addr + 0)) << 20) | \
-					((u32)(*(u8 *)(addr + 1)) << 12) | \
-					((u32)(*(u8 *)(addr + 2)) << 4) | \
-					((u32)(*(u8 *)(addr + 3)) >> 4))
-
-#define mVPOWERs(addr)			sign_extend32(mVPOWERu(addr), 3)
-
-#define mVBUS_SENSEu(addr)		(((u16)(*(u8 *)(addr + 0)) << 8) | \
-					((u16)(*(u8 *)(addr + 1)) << 0))
-
-#define mVBUS_SENSEs(addr)		((__s16)mVBUS_SENSEu(addr))
-
-static int pac193x_retrieve_data(struct pac193x_chip_info *chip_info,
-					u32 wait_time);
-static int pac193x_send_rfsh(struct pac193x_chip_info *chip_info,
-				bool refresh_v, u32 wait_time);
-static int pac193x_reg_snapshot(struct pac193x_chip_info *chip_info,
-				bool do_rfsh, bool refresh_v, u32 wait_time);
-static int pac193x_remove(struct i2c_client *client);
-static const char *pac193x_get_of_match_entry(struct i2c_client *client);
-
-#define PAC193x_VPOWER_ACC_CHANNEL(_index, _address) {			\
-	.type = IIO_ENERGY,						\
-	.address = (_address),						\
-	.indexed = 1,							\
-	.channel = (_index),						\
-	.info_mask_separate = BIT(IIO_CHAN_INFO_AVERAGE_RAW) |		\
-				BIT(IIO_CHAN_INFO_SCALE),		\
-	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
-	.scan_index = (_index),						\
-	.scan_type = {							\
-		.sign = 'u',						\
-		.realbits = PAC193X_ENERGY_U_RES,			\
-		.storagebits = PAC193X_ENERGY_U_RES,			\
-		.shift = 0,						\
-		.endianness = IIO_CPU,					\
-	}								\
-}
-
-#define PAC193x_VBUS_CHANNEL(_index, _address) {			\
-	.type = IIO_VOLTAGE,						\
-	.address = (_address),						\
-	.indexed = 1,							\
-	.channel = (_index),						\
-	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),			\
-	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),		\
-	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
-	.scan_index = (_index),						\
-	.scan_type = {							\
-		.sign = 'u',						\
-		.realbits = PAC193X_VOLTAGE_U_RES,			\
-		.storagebits = PAC193X_VOLTAGE_U_RES,			\
-		.shift = 0,						\
-		.endianness = IIO_CPU,					\
-	}								\
+/* macros to extract the parameters */
+#define PAC193X_MVBUS_SENSES(x)		sign_extend32((u32)(x), 15)
+
+#define PAC193X_VPOWER_ACC_CHANNEL(_index, _si, _address) {			\
+.type = IIO_ENERGY,							\
+.address = (_address),							\
+.indexed = 1,								\
+.channel = (_index),							\
+.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)	|			\
+BIT(IIO_CHAN_INFO_SCALE),			\
+.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),		\
+.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
+.scan_index = (_si),							\
+.scan_type = {								\
+	.sign = 'u',							\
+	.realbits = PAC193X_ENERGY_U_RES,				\
+	.storagebits = PAC193X_ENERGY_U_RES,				\
+	.endianness = IIO_CPU,						\
+}									\
 }
 
-#define PAC193x_VBUS_AVG_CHANNEL(_index, _address) {			\
-	.type = IIO_VOLTAGE,						\
-	.address = (_address),						\
-	.indexed = 1,							\
-	.channel = (_index),						\
-	.info_mask_separate = BIT(IIO_CHAN_INFO_AVERAGE_RAW),		\
-	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |		\
-				BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),	\
-	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
-	.scan_index = (_index),						\
-	.scan_type = {							\
-		.sign = 'u',						\
-		.realbits = PAC193X_VOLTAGE_U_RES,			\
-		.storagebits = PAC193X_VOLTAGE_U_RES,			\
-		.shift = 0,						\
-		.endianness = IIO_CPU,					\
-	}								\
+#define PAC193X_VBUS_CHANNEL(_index, _si, _address) {				\
+.type = IIO_VOLTAGE,							\
+.address = (_address),							\
+.indexed = 1,								\
+.channel = (_index),							\
+.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),				\
+.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),		\
+.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
+.scan_index = (_si),							\
+.scan_type = {								\
+	.sign = 'u',							\
+	.realbits = PAC193X_VOLTAGE_U_RES,				\
+	.storagebits = PAC193X_VOLTAGE_U_RES,				\
+	.endianness = IIO_CPU,						\
+}									\
 }
 
-#define PAC193x_VSENSE_CHANNEL(_index, _address) {			\
-	.type = IIO_CURRENT,						\
-	.address = (_address),						\
-	.indexed = 1,							\
-	.channel = (_index),						\
-	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),			\
-	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
-	.scan_index = (_index),						\
-	.scan_type = {							\
-		.sign = 'u',						\
-		.realbits = PAC193X_CURRENT_U_RES,			\
-		.storagebits = PAC193X_CURRENT_U_RES,			\
-		.shift = 0,						\
-		.endianness = IIO_CPU,					\
-	}								\
+#define PAC193X_VBUS_AVG_CHANNEL(_index, _si, _address) {			\
+.type = IIO_VOLTAGE,							\
+.address = (_address),							\
+.indexed = 1,								\
+.channel = (_index),							\
+.info_mask_separate = BIT(IIO_CHAN_INFO_AVERAGE_RAW)			\
+| BIT(IIO_CHAN_INFO_SCALE),			\
+.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),		\
+.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
+.scan_index = (_si),							\
+.scan_type = {								\
+	.sign = 'u',							\
+	.realbits = PAC193X_VOLTAGE_U_RES,				\
+	.storagebits = PAC193X_VOLTAGE_U_RES,				\
+	.endianness = IIO_CPU,						\
+}									\
 }
 
-#define PAC193x_VSENSE_AVG_CHANNEL(_index, _address) {			\
-	.type = IIO_CURRENT,						\
-	.address = (_address),						\
-	.indexed = 1,							\
-	.channel = (_index),						\
-	.info_mask_separate = BIT(IIO_CHAN_INFO_AVERAGE_RAW) |		\
-			BIT(IIO_CHAN_INFO_SCALE),			\
-	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),\
-	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
-	.scan_index = (_index),						\
-	.scan_type = {							\
-		.sign = 'u',						\
-		.realbits = PAC193X_CURRENT_U_RES,			\
-		.storagebits = PAC193X_CURRENT_U_RES,			\
-		.shift = 0,						\
-		.endianness = IIO_CPU,					\
-	}								\
+#define PAC193X_VSENSE_CHANNEL(_index, _si, _address) {				\
+.type = IIO_CURRENT,							\
+.address = (_address),							\
+.indexed = 1,								\
+.channel = (_index),							\
+.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),				\
+.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),		\
+.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
+.scan_index = (_si),							\
+.scan_type = {								\
+	.sign = 'u',							\
+	.realbits = PAC193X_CURRENT_U_RES,				\
+	.storagebits = PAC193X_CURRENT_U_RES,				\
+	.endianness = IIO_CPU,						\
+}									\
 }
 
-#define PAC193x_VPOWER_CHANNEL(_index, _address) {			\
-	.type = IIO_POWER,						\
-	.address = (_address),						\
-	.indexed = 1,							\
-	.channel = (_index),						\
-	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |			\
-			BIT(IIO_CHAN_INFO_SCALE),			\
-	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
-	.scan_index = (_index),						\
-	.scan_type = {							\
-		.sign = 'u',						\
-		.realbits = PAC193X_POWER_U_RES,			\
-		.storagebits = 32,					\
-		.shift = 4,						\
-		.endianness = IIO_CPU,					\
-	}								\
+#define PAC193X_VSENSE_AVG_CHANNEL(_index, _si, _address) {			\
+.type = IIO_CURRENT,							\
+.address = (_address),							\
+.indexed = 1,								\
+.channel = (_index),							\
+.info_mask_separate = BIT(IIO_CHAN_INFO_AVERAGE_RAW) |			\
+BIT(IIO_CHAN_INFO_SCALE),				\
+.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),		\
+.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
+.scan_index = (_si),							\
+.scan_type = {								\
+	.sign = 'u',							\
+	.realbits = PAC193X_CURRENT_U_RES,				\
+	.storagebits = PAC193X_CURRENT_U_RES,				\
+	.endianness = IIO_CPU,						\
+}									\
 }
 
-#define PAC193x_SOFT_TIMESTAMP(_index) {				\
-	.type = IIO_TIMESTAMP,						\
-	.channel = -1,							\
-	.scan_index = (_index),						\
-	.scan_type = {							\
-		.sign = 's',						\
-		.realbits = 64,						\
-		.storagebits = 64,					\
-		}							\
+#define PAC193X_VPOWER_CHANNEL(_index, _si, _address) {				\
+.type = IIO_POWER,							\
+.address = (_address),							\
+.indexed = 1,								\
+.channel = (_index),							\
+.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |				\
+BIT(IIO_CHAN_INFO_SCALE),				\
+.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ),		\
+.info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
+.scan_index = (_si),							\
+.scan_type = {								\
+	.sign = 'u',							\
+	.realbits = PAC193X_POWER_U_RES,				\
+	.storagebits = 32,						\
+	.shift = 4,							\
+	.endianness = IIO_CPU,						\
+}									\
 }
 
 static const struct iio_chan_spec pac193x_single_channel[] = {
-	PAC193x_VPOWER_ACC_CHANNEL(0, PAC193X_VPOWER_ACC_0_ADDR),
-	PAC193x_VPOWER_CHANNEL(0, PAC193X_VPOWER_0_ADDR),
-	PAC193x_VBUS_CHANNEL(0, PAC193X_VBUS_0_ADDR),
-	PAC193x_VSENSE_CHANNEL(0, PAC193X_VSENSE_0_ADDR),
-	PAC193x_VBUS_AVG_CHANNEL(0, PAC193X_VBUS_AVG_0_ADDR),
-	PAC193x_VSENSE_AVG_CHANNEL(0, PAC193X_VSENSE_AVG_0_ADDR),
+	PAC193X_VPOWER_ACC_CHANNEL(0, 0, PAC193X_VPOWER_ACC_1_ADDR),
+	PAC193X_VPOWER_CHANNEL(0, 0, PAC193X_VPOWER_1_ADDR),
+	PAC193X_VBUS_CHANNEL(0, 0, PAC193X_VBUS_1_ADDR),
+	PAC193X_VSENSE_CHANNEL(0, 0, PAC193X_VSENSE_1_ADDR),
+	PAC193X_VBUS_AVG_CHANNEL(0, 0, PAC193X_VBUS_AVG_1_ADDR),
+	PAC193X_VSENSE_AVG_CHANNEL(0, 0, PAC193X_VSENSE_AVG_1_ADDR),
 };
 
-static const struct iio_chan_spec pac193x_ts[] = {
-	PAC193x_SOFT_TIMESTAMP(0),
-};
 /* Low-level I2c functions */
-static int pac193x_i2c_read(struct i2c_client *client, u8 reg_addr,
-				void *databuf, u8 len)
+static int pac193x_i2c_read(struct i2c_client *client, u8 reg_addr, void *databuf, u8 len)
 {
 	int ret;
 	struct i2c_msg msgs[2] = {
-		{ .addr = client->addr, .len = 1,
-			.buf = (u8 *) &reg_addr, .flags = 0 },
-		{ .addr = client->addr, .len = len,
-			.buf = databuf, .flags = I2C_M_RD } };
-
-	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
-	if (ret < 0) {
-		dev_err(&client->dev,
-		"failed reading data from register 0x%02X\n", reg_addr);
-		return ret;
-	}
-	return 0;
-}
-
-static int pac193x_i2c_write_byte(struct i2c_client *client,
-					u8 reg_addr, u8 val)
-{
-	int ret;
-	u8 buf[2];
-	struct i2c_msg msgs[1] = {
-		{ .addr = client->addr, .len = sizeof(buf),
-			.buf = (u8 *) &buf, .flags = 0 } };
-	buf[0] = reg_addr;
-	buf[1] = val;
-
-	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
-	if (ret < 0) {
-		dev_err(&client->dev,
-			"failed writing register 0x%02X\n", reg_addr);
-		return ret;
-	}
-	return 0;
-}
-
-static int pac193x_i2c_send_byte(struct i2c_client *client, u8 reg_addr)
-{
-	int ret;
-	u8 buf;
-	struct i2c_msg msgs[1] = {
-		{ .addr = client->addr, .len = sizeof(buf),
-			.buf = (u8 *) &buf, .flags = 0 } };
-	buf = reg_addr;
-
+		{ .addr = client->addr,
+			.len = 1,
+			.buf = (u8 *)&reg_addr,
+			.flags = 0
+		},
+		{ .addr = client->addr,
+			.len = len,
+			.buf = databuf,
+			.flags = I2C_M_RD
+		}
+	};
+	
 	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
-	if (ret < 0) {
-		dev_err(&client->dev,
-			"failed sending byte to register 0x%02X\n", reg_addr);
+	if (ret < 0)
 		return ret;
-	}
+	
 	return 0;
 }
 
-static int pac193x_i2c_write(struct i2c_client *client, u8 reg_addr,
-				int len, u8 *data)
+static int pac193x_i2c_write(struct i2c_client *client, u8 reg_addr, u8 *data, int len)
 {
 	int ret;
-	u8 send[len + 1];
-	struct i2c_msg msg = { .addr = client->addr,
-				.len = len + 1, .flags = 0 };
-
+	u8 send[PAC193X_MAX_REGISTER_LENGTH + 1];
+	
 	send[0] = reg_addr;
 	memcpy(&send[1], data, len * sizeof(u8));
-	msg.buf = send;
-
-	ret = i2c_transfer(client->adapter, &msg, 1);
+	
+	ret = i2c_master_send(client, send, len + 1);
 	if (ret < 0) {
 		dev_err(&client->dev,
-			"failed writing data from register 0x%02X\n",
-			reg_addr);
+				"failed writing data from register 0x%02X\n", reg_addr);
 		return ret;
 	}
+	
 	return 0;
 }
 
-static int pac193x_match_samp_rate(struct pac193x_chip_info *chip_info,
-					u32 new_samp_rate)
+static int pac193x_match_samp_rate(struct pac193x_chip_info *chip_info, u32 new_samp_rate)
 {
 	int cnt;
-
+	
 	for (cnt = 0; cnt < ARRAY_SIZE(samp_rate_map_tbl); cnt++) {
 		if (new_samp_rate == samp_rate_map_tbl[cnt]) {
-			chip_info->chip_reg_data.crt_samp_speed_bitfield = cnt;
-			break;
+			chip_info->crt_samp_spd_bitfield = cnt;
+			return 0;
 		}
 	}
-	if (cnt == ARRAY_SIZE(samp_rate_map_tbl)) {
-		/* not a valid sample rate value */
-		return cnt;
-	}
-	return 0;
+	
+	/* not a valid sample rate value */
+	return -EINVAL;
 }
 
-static ssize_t rst_en_regs_wo_param_store
-			(struct device *dev, struct device_attribute *attr,
-			 const char *buf, size_t count)
+static ssize_t shunt_value_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct pac193x_chip_info *chip_info = iio_priv(indio_dev);
-	int val;
-	int cnt;
-
-	if (kstrtoint(buf, 10, &val))
-		return -EINVAL;
-	if (!(val == 0 || val == 1))
-		return -EINVAL;
-
-	mutex_lock(&chip_info->lock);
-	for (cnt = 0; cnt < chip_info->phys_channels; cnt++)
-		chip_info->chip_reg_data.energy_sec_acc[cnt] = 0;
-	mutex_unlock(&chip_info->lock);
-	return count;
+	int len = 0;
+	int target = (int)(attr->attr.name[strlen(attr->attr.name) - 1] - '0') - 1;
+	
+	len += sprintf(buf, "%u\n", chip_info->shunts[target]);
+	
+	return len;
 }
 
-static ssize_t shunt_value_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+static ssize_t channel_name_show(struct device *dev,
+								 struct device_attribute *attr,
+								 char *buf)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct pac193x_chip_info *chip_info = iio_priv(indio_dev);
-	unsigned int i;
 	int len = 0;
-	int cnt;
-
-	for (cnt = 0; cnt < chip_info->phys_channels; cnt++) {
-		i = chip_info->shunts[cnt];
-		len += sprintf(buf + len, "%d ", i);
-	}
-	buf[len - 1] = '\n';
+	int target = (int)(attr->attr.name[strlen(attr->attr.name) - 1] - '0') - 1;
+	
+	len += sprintf(buf, "%s\n", chip_info->channel_names[target]);
+	
 	return len;
 }
 
 static ssize_t shunt_value_store(struct device *dev,
-			struct device_attribute *attr,
-			const char *buf, size_t count)
+								 struct device_attribute *attr,
+								 const char *buf, size_t count)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct pac193x_chip_info *chip_info = iio_priv(indio_dev);
-	int chan, sh_val;
-	char *blank, mybuff[8];
-
-	blank = strchr(buf, ' ');
-	if (!blank) {
-		dev_err(dev, "%s: Missing parameters\n", "shunt_value");
-		return -EINVAL;
-	}
-	memset(mybuff, 0, sizeof(mybuff));
-	memcpy(mybuff, buf, blank - buf);
-	if (kstrtoint(mybuff, 10, &chan)) {
-		dev_err(dev, "%s: Channel index is not a number\n",
-			"shunt_value");
-		return -EINVAL;
-	}
-	if (chan < 0) {
-		dev_err(dev, "%s: Negative channel values not allowed\n",
-			"shunt_value");
-		return -EINVAL;
-	}
-	if (chan >= chip_info->phys_channels) {
-		dev_err(dev,
-			"%s: Channel index out of range\n",
-			"shunt_value");
-		return -EINVAL;
-	}
-	if (kstrtoint(++blank, 10, &sh_val)) {
-		dev_err(dev, "%s: Shunt value is not a number\n",
-			"shunt_value");
-		return -EINVAL;
-	}
-	if (sh_val < 0) {
-		dev_err(dev, "%s: Negative shunt values not allowed\n",
-			"shunt_value");
+	int sh_val, target;
+	
+	target = (int)(attr->attr.name[strlen(attr->attr.name) - 1] - '0') - 1;
+	if (kstrtouint(buf, 10, &sh_val)) {
+		dev_err(dev, "Shunt value is not valid\n");
 		return -EINVAL;
 	}
+	
 	mutex_lock(&chip_info->lock);
-	chip_info->shunts[chan] = sh_val;
+	chip_info->shunts[target] = sh_val;
 	mutex_unlock(&chip_info->lock);
+	
 	return count;
 }
 
-static IIO_DEVICE_ATTR(rst_en_regs_wo_param, 0200,
-		       NULL, rst_en_regs_wo_param_store, 0);
-
-
-static IIO_DEVICE_ATTR(shunt_value, 0644,
-			shunt_value_show,
-			shunt_value_store, 0);
-
-#define PAC193x_DEV_ATTR(name) (&iio_dev_attr_##name.dev_attr.attr)
-
-static struct attribute *pac193x_custom_attributes[] = {
-	PAC193x_DEV_ATTR(rst_en_regs_wo_param),
-	PAC193x_DEV_ATTR(shunt_value),
-	NULL
-};
-
-static const struct attribute_group pac193x_group = {
-	.attrs = pac193x_custom_attributes,
-};
-/*
- * pac193x_read_raw() - data read function.
- * @indio_dev:	the struct iio_dev associated with this device instance
- * @chan:	the channel whose data is to be read
- * @val:	first element of returned value (typically INT)
- * @val2:	second element of returned value (typically MICRO)
- * @mask:	what we actually want to read as per the info_mask_*
- *		in iio_chan_spec.
- */
-static int pac193x_read_raw(struct iio_dev *indio_dev,
-			      struct iio_chan_spec const *chan,
-			      int *val,
-			      int *val2,
-			      long mask)
-{
-	struct pac193x_chip_info *chip_info = iio_priv(indio_dev);
-	int ret = -EINVAL;
-	unsigned long tmp;
-
-	ret = pac193x_retrieve_data(chip_info, PAC193x_MIN_UPDATE_WAIT_TIME);
-	if (ret < 0)
-		return ret;
-	/* check what data is requested from us */
-	ret = -EINVAL;
-
-	switch (mask) {
-	/* Raw data requested */
-	case IIO_CHAN_INFO_RAW:
-		switch (chan->type) {
-		/* Voltages */
-		case IIO_VOLTAGE:
-			switch (chan->address) {
-			case PAC193X_VBUS_0_ADDR:
-			case PAC193X_VBUS_1_ADDR:
-			case PAC193X_VBUS_2_ADDR:
-			case PAC193X_VBUS_3_ADDR:
-				*val =
-				chip_info->chip_reg_data.vbus[chan->channel];
-				return IIO_VAL_INT;
-
-			default:
-				return -EINVAL;
-			}
-			break;
-		/* Currents */
-		case IIO_CURRENT:
-			switch (chan->address) {
-			case PAC193X_VSENSE_0_ADDR:
-			case PAC193X_VSENSE_1_ADDR:
-			case PAC193X_VSENSE_2_ADDR:
-			case PAC193X_VSENSE_3_ADDR:
-				*val =
-				chip_info->chip_reg_data.vsense[chan->channel];
-				return IIO_VAL_INT;
-			default:
-				return -EINVAL;
-			}
-			break;
-		/* Power */
-		case IIO_POWER:
-			switch (chan->address) {
-			case PAC193X_VPOWER_0_ADDR:
-			case PAC193X_VPOWER_1_ADDR:
-			case PAC193X_VPOWER_2_ADDR:
-			case PAC193X_VPOWER_3_ADDR:
-				*val =
-				chip_info->chip_reg_data.vpower[chan->channel];
-				return IIO_VAL_INT;
-			default:
-				return -EINVAL;
-			}
-			break;
-		default:
-			return -EINVAL;
-		}
-		break;
-	/* Average raw data */
-	case IIO_CHAN_INFO_AVERAGE_RAW:
-		switch (chan->type) {
-		/* Voltages */
-		case IIO_VOLTAGE:
-			switch (chan->address) {
-			case PAC193X_VBUS_AVG_0_ADDR:
-			case PAC193X_VBUS_AVG_1_ADDR:
-			case PAC193X_VBUS_AVG_2_ADDR:
-			case PAC193X_VBUS_AVG_3_ADDR:
-				*val =
-			chip_info->chip_reg_data.vbus_avg[chan->channel];
-				return IIO_VAL_INT;
-
-			default:
-				return -EINVAL;
-			}
-			break;
-		/* Currents */
-		case IIO_CURRENT:
-			switch (chan->address) {
-			case PAC193X_VSENSE_AVG_0_ADDR:
-			case PAC193X_VSENSE_AVG_1_ADDR:
-			case PAC193X_VSENSE_AVG_2_ADDR:
-			case PAC193X_VSENSE_AVG_3_ADDR:
-				*val =
-			chip_info->chip_reg_data.vsense_avg[chan->channel];
-				return IIO_VAL_INT;
-
-			default:
-				return -EINVAL;
-			}
-			break;
-		/* Energy */
-		case IIO_ENERGY:
-			switch (chan->address) {
-			case PAC193X_VPOWER_ACC_0_ADDR:
-			case PAC193X_VPOWER_ACC_1_ADDR:
-			case PAC193X_VPOWER_ACC_2_ADDR:
-			case PAC193X_VPOWER_ACC_3_ADDR:
-	/* reduce the value only to the higher 32 bits in order to fit the val
-	 * parameter which is int(32b)
-	 */
-				*val =
-(int)(chip_info->chip_reg_data.energy_sec_acc[chan->channel] >>
-PAC193X_ENERGY_SHIFT_MAIN_VAL);
-				return IIO_VAL_INT;
-			default:
-				return -EINVAL;
-			}
-			break;
-		default:
-			return -EINVAL;
-		}
-		break;
-	case IIO_CHAN_INFO_SCALE:
-		switch (chan->address) {
-		/* Voltages - scale for millivolts */
-		case PAC193X_VBUS_0_ADDR:
-		case PAC193X_VBUS_1_ADDR:
-		case PAC193X_VBUS_2_ADDR:
-		case PAC193X_VBUS_3_ADDR:
-		case PAC193X_VBUS_AVG_0_ADDR:
-		case PAC193X_VBUS_AVG_1_ADDR:
-		case PAC193X_VBUS_AVG_2_ADDR:
-		case PAC193X_VBUS_AVG_3_ADDR:
-			*val = PAC193X_VOLTAGE_MILLIVOLTS_MAX;
-			if (chan->scan_type.sign == 'u')
-				*val2 = PAC193X_VOLTAGE_U_RES;
-			else
-				*val2 = PAC193X_VOLTAGE_S_RES;
-			return IIO_VAL_FRACTIONAL_LOG2;
-		/* Currents - scale for mA - depends on the
-		 * channel's shunt value
-		 * ( 100mV * 1000000) / (2^16 * shunt(uohm))
-		 */
-		case PAC193X_VSENSE_0_ADDR:
-		case PAC193X_VSENSE_1_ADDR:
-		case PAC193X_VSENSE_2_ADDR:
-		case PAC193X_VSENSE_3_ADDR:
-		case PAC193X_VSENSE_AVG_0_ADDR:
-		case PAC193X_VSENSE_AVG_1_ADDR:
-		case PAC193X_VSENSE_AVG_2_ADDR:
-		case PAC193X_VSENSE_AVG_3_ADDR:
-			tmp = (PAC193X_VSENSE_MILLIVOLTS_MAX * 1000000)/
-				chip_info->shunts[chan->channel];
-			*val = (int)tmp;
-			if (chan->scan_type.sign == 'u')
-				*val2 = PAC193X_CURRENT_U_RES;
-			else
-				*val2 = PAC193X_CURRENT_S_RES;
-			return IIO_VAL_FRACTIONAL_LOG2;
-		/* Power - mW - it will use the combined scale
-		 * for current and voltage
-		 * current(mA) * voltage(mV) = power (uW)
-		 */
-		case PAC193X_VPOWER_0_ADDR:
-		case PAC193X_VPOWER_1_ADDR:
-		case PAC193X_VPOWER_2_ADDR:
-		case PAC193X_VPOWER_3_ADDR:
-			tmp = (PAC193X_VSENSE_MILLIVOLTS_MAX) * 100 *
-				((10000 * PAC193X_VOLTAGE_MILLIVOLTS_MAX)/
-					chip_info->shunts[chan->channel]);
-			*val = (int)tmp;
-			if (chan->scan_type.sign == 'u')
-				*val2 = PAC193X_POWER_U_RES;
-			else
-				*val2 = PAC193X_POWER_S_RES;
-			return IIO_VAL_FRACTIONAL_LOG2;
-		case PAC193X_VPOWER_ACC_0_ADDR:
-		case PAC193X_VPOWER_ACC_1_ADDR:
-		case PAC193X_VPOWER_ACC_2_ADDR:
-		case PAC193X_VPOWER_ACC_3_ADDR:
-		/* compute the scale for energy (Watt-second or
-		 * Joule). The Energy mean raw value was the
-		 * higher 32 bits of the s64 variable. The right
-		 * shifted raw value was needed in order to
-		 * prevent the underflow of the scale value.
-		 * Both the raw and the scale are accepting only
-		 * signed 32bits values
-		 */
-			tmp = (PAC193X_VSENSE_MILLIVOLTS_MAX *
-				PAC193X_VOLTAGE_MILLIVOLTS_MAX)/
-				chip_info->shunts[chan->channel];
-			*val = (int)tmp;
-			if (chan->scan_type.sign == 'u')
-				*val2 = PAC193X_ENERGY_U_RES -
-					PAC193X_ENERGY_SHIFT_MAIN_VAL;
-			else
-				*val2 = PAC193X_ENERGY_S_RES -
-					PAC193X_ENERGY_SHIFT_MAIN_VAL;
-			return IIO_VAL_FRACTIONAL_LOG2;
-		default:
-			return -EINVAL;
-		}
-		break;
-	case IIO_CHAN_INFO_SAMP_FREQ:
-		*val = (int)chip_info->sample_rate_value;
-		return IIO_VAL_INT;
-	default:
-		return -EINVAL;
-	}
-	return ret;
-}
-/*
- * pac193x_write_raw() - data write function.
- * @indio_dev:	the struct iio_dev associated with this device instance
- * @chan:	the channel whose data is to be written
- * @val:	first element of value to set (typically INT)
- * @val2:	second element of value to set (typically MICRO)
- * @mask:	what we actually want to write as per the info_mask_*
- *		in iio_chan_spec.
- *
- * Note that all raw writes are assumed IIO_VAL_INT and info mask elements
- * are assumed to be IIO_INT_PLUS_MICRO unless the callback write_raw_get_fmt
- * in struct iio_info is provided by the driver.
- */
-static int pac193x_write_raw(struct iio_dev *indio_dev,
-			       struct iio_chan_spec const *chan,
-			       int val,
-			       int val2,
-			       long mask)
+static int pac193x_read_avail(struct iio_dev *indio_dev,
+							  struct iio_chan_spec const *channel,
+							  const int **vals, int *type, int *length, long mask)
 {
-	struct pac193x_chip_info *chip_info = iio_priv(indio_dev);
-	struct i2c_client *client = chip_info->client;
-	int ret = -EINVAL;
-	u32 old_samp_rate;
-
-	if (iio_buffer_enabled(indio_dev))
-		return -EBUSY;
-
 	switch (mask) {
-	case IIO_CHAN_INFO_SAMP_FREQ:
-		if (pac193x_match_samp_rate(chip_info, (u16)val))
-			return -EINVAL;
-		/* store the old sampling rate */
-		old_samp_rate = chip_info->sample_rate_value;
-		/* we have a valid sample rate */
-		chip_info->sample_rate_value = (u16)val;
-		/* now lock the access to the chip, write the new
-		 * sampling value and trigger a snapshot(incl refresh)
-		 */
-		mutex_lock(&chip_info->lock);
-		/* enable ALERT pin */
-		ret = pac193x_i2c_write_byte(chip_info->client,
-			PAC193X_CTRL_REG,
-		CTRL_REG(chip_info->chip_reg_data.crt_samp_speed_bitfield,
-		0, 0, 1, 0, 0));
-		if (ret < 0) {
-			dev_err(&client->dev,
-			"%s - cannot write PAC193x ctrl reg at 0x%02X\n",
-				__func__, PAC193X_CTRL_REG);
-			mutex_unlock(&chip_info->lock);
-			return ret;
-		}
-		/* unlock the access towards the chip - register
-		 * snapshot includes its own access lock
-		 */
-		mutex_unlock(&chip_info->lock);
-		/* now, force a snapshot with refresh - call retrieve
-		 * data in order to update the refresh timer
-		 * alter the timestamp in order to force trigger a
-		 * register snapshot and a timestamp update
-		 */
-		chip_info->chip_reg_data.jiffies_tstamp -=
-				msecs_to_jiffies(PAC193X_MIN_POLLING_TIME);
-		ret = pac193x_retrieve_data(chip_info,
-				(1024/old_samp_rate) * 1000);
-		if (ret < 0) {
-			dev_err(&client->dev,
-"%s - cannot snapshot PAC193x ctrl and measurement regs\n", __func__);
-			return ret;
-		}
-		ret = 0;
-	break;
+		case IIO_CHAN_INFO_SAMP_FREQ:
+			*type = IIO_VAL_INT;
+			*vals = samp_rate_map_tbl;
+			*length = ARRAY_SIZE(samp_rate_map_tbl);
+			return IIO_AVAIL_LIST;
 	}
-	return ret;
+	
+	return -EINVAL;
 }
 
-static const struct iio_info pac193x_info = {
-	.attrs = &pac193x_group,
-//	.driver_module = THIS_MODULE,
-	.read_raw = pac193x_read_raw,
-	.write_raw = pac193x_write_raw,
-};
-
-static int pac193x_send_rfsh(struct pac193x_chip_info *chip_info,
-				bool refresh_v, u32 wait_time)
+static int pac193x_send_refresh(struct pac193x_chip_info *chip_info,
+								u8 refresh_cmd, u32 wait_time)
 {
 	/* this function only sends REFRESH or REFRESH_V */
 	struct i2c_client *client = chip_info->client;
 	int ret;
-	u8 rfsh_option;
-	/* if refresh_v is not false, send a REFRESH_V instead
-	 * (doesn't reset the accumulators)
-	 */
-	rfsh_option = PAC193X_REFRESH_REG;
-	if (refresh_v)
-		rfsh_option = PAC193X_REFRESH_V_REG;
-	/* now write a REFRESH or a REFRESH_V command */
-	ret = pac193x_i2c_send_byte(chip_info->client, rfsh_option);
-	if (ret < 0) {
-		dev_err(&client->dev,
-"%s - cannot send byte to PAC193x 0x%02X reg\n", __func__, rfsh_option);
+	u8 bidir_reg;
+	bool revision_bug = false;
+	
+	if (chip_info->chip_revision == 2 || chip_info->chip_revision == 3) {
+		/*
+		 * chip rev 2 and 3 bug workaround
+		 * see: PAC193X Family Data Sheet Errata DS80000836A.pdf
+		 */
+		revision_bug = true;
+		
+		bidir_reg = PAC193X_NEG_PWR_CH1_BIDI(chip_info->bi_dir[PAC193X_CH_1]) |
+		PAC193X_NEG_PWR_CH2_BIDI(chip_info->bi_dir[PAC193X_CH_2]) |
+		PAC193X_NEG_PWR_CH3_BIDI(chip_info->bi_dir[PAC193X_CH_3]) |
+		PAC193X_NEG_PWR_CH4_BIDI(chip_info->bi_dir[PAC193X_CH_4]) |
+		PAC193X_NEG_PWR_CH1_BIDV(chip_info->bi_dir[PAC193X_CH_1]) |
+		PAC193X_NEG_PWR_CH2_BIDV(chip_info->bi_dir[PAC193X_CH_2]) |
+		PAC193X_NEG_PWR_CH3_BIDV(chip_info->bi_dir[PAC193X_CH_3]) |
+		PAC193X_NEG_PWR_CH4_BIDV(chip_info->bi_dir[PAC193X_CH_4]);
+		
+		ret = i2c_smbus_write_byte_data(client,
+										PAC193X_CTRL_STAT_REGS_ADDR +
+										PAC193X_NEG_PWR_REG_OFF,
+								  bidir_reg);
+		if (ret)
+			return ret;
+	}
+	
+	ret = i2c_smbus_write_byte(client, refresh_cmd);
+	if (ret) {
+		dev_err(&client->dev, "%s - cannot send 0x%02X\n",
+				__func__, refresh_cmd);
 		return ret;
 	}
+	
+	if (revision_bug) {
+		/*
+		 * chip rev 2 and 3 bug workaround - write again the same register
+		 * write the updated registers back
+		 */
+		ret = i2c_smbus_write_byte_data(client,
+										PAC193X_CTRL_STAT_REGS_ADDR +
+										PAC193X_NEG_PWR_REG_OFF, bidir_reg);
+		if (ret)
+			return ret;
+	}
+	
 	/* register data retrieval timestamp */
-	chip_info->chip_reg_data.jiffies_tstamp = jiffies;
+	chip_info->jiffies_tstamp = jiffies;
+	
 	/* wait till the data is available */
 	usleep_range(wait_time, wait_time + 100);
+	
 	return ret;
 }
 
 static int pac193x_reg_snapshot(struct pac193x_chip_info *chip_info,
-		bool do_rfsh, bool refresh_v, u32 wait_time)
+								bool do_refresh, u8 refresh_cmd, u32 wait_time)
 {
 	int ret;
 	struct i2c_client *client = chip_info->client;
-	u8 offset_reg_data, samp_shift;
-	int cnt;
-
-	/* protect the access to the chip */
+	u8 samp_shift, ctrl_regs_tmp;
+	u8 *offset_reg_data_p;
+	u16 tmp_value;
+	u32 samp_rate, cnt, tmp;
+	s64 curr_energy, inc;
+	u64 tmp_energy;
+	struct reg_data *reg_data;
+	
 	mutex_lock(&chip_info->lock);
-
-	if (do_rfsh) {
-		ret = pac193x_send_rfsh(chip_info, refresh_v, wait_time);
+	
+	if (do_refresh) {
+		ret = pac193x_send_refresh(chip_info, refresh_cmd, wait_time);
 		if (ret < 0) {
 			dev_err(&client->dev,
-"%s - cannot end refresh towards PAC193x\n", __func__);
+					"%s - cannot send refresh\n",
+		   __func__);
 			goto reg_snapshot_err;
 		}
 	}
+	
 	/* read the ctrl/status registers for this snapshot */
-	ret = pac193x_i2c_read(chip_info->client, PAC193X_CTRL_STAT_REGS_ADDR,
-		(u8 *) chip_info->chip_reg_data.ctrl_regs,
-		PAC193X_CTRL_REG_SNAPSHOT_LEN);
-	if (ret < 0) {
+	ret = pac193x_i2c_read(client, PAC193X_CTRL_STAT_REGS_ADDR,
+						   (u8 *)chip_info->chip_reg_data.ctrl_regs,
+						   PAC193X_CTRL_REG_LEN);
+	if (ret) {
 		dev_err(&client->dev,
-				"%s - cannot read PAC193x regs from 0x%02X\n",
-				__func__, PAC193X_CTRL_STAT_REGS_ADDR);
+				"%s - cannot read ctrl/status registers\n",
+		  __func__);
 		goto reg_snapshot_err;
 	}
+	
+	reg_data = &chip_info->chip_reg_data;
+	
 	/* read the data registers */
-	ret = pac193x_i2c_read(chip_info->client, PAC193X_ACC_COUNT_REG,
-		(u8 *) chip_info->chip_reg_data.meas_regs,
-		PAC193X_MEAS_REG_SNAPSHOT_LEN);
-	if (ret < 0) {
+	ret = pac193x_i2c_read(client, PAC193X_ACC_COUNT_REG_ADDR,
+						   (u8 *)reg_data->meas_regs, PAC193X_MEAS_REG_LEN);
+	if (ret) {
 		dev_err(&client->dev,
-				"%s - cannot read PAC193x regs from 0x%02X\n",
-				__func__, PAC193X_ACC_COUNT_REG);
+				"%s - cannot read ACC_COUNT register: %d:%d\n",
+		  __func__, ret, PAC193X_MEAS_REG_LEN);
 		goto reg_snapshot_err;
 	}
-	offset_reg_data = 0;
-	chip_info->chip_reg_data.acc_count =
-	mACC_COUNT(&chip_info->chip_reg_data.meas_regs[offset_reg_data]);
-	/* move the register offset */
-	offset_reg_data += PAC193X_ACC_REG_LEN;
+	
+	/* see how much shift is required by the sample rate */
+	samp_rate = samp_rate_map_tbl[((reg_data->ctrl_regs[PAC193X_CTRL_LAT_REG_OFF]) >> 6)];
+	samp_shift = get_count_order(samp_rate);
+	
+	ctrl_regs_tmp = reg_data->ctrl_regs[PAC193X_CHANNEL_DIS_LAT_REG_OFF];
+	offset_reg_data_p = &reg_data->meas_regs[PAC193X_ACC_REG_LEN];
+	
 	/* start with VPOWER_ACC */
 	for (cnt = 0; cnt < chip_info->phys_channels; cnt++) {
-		/* check if the channel is active(within the data read from
-		 * the chip), skip all fields if disabled
-		 */
-		if (((
-chip_info->chip_reg_data.ctrl_regs[PAC193X_CHANNEL_DIS_LAT_REG_OFF] << cnt) &
-			0x80) == 0) {
-			/* add the power_acc field */
-			if (chip_info->chip_reg_data.bi_dir[cnt]) {
-				/* bi-directional channel */
-				chip_info->chip_reg_data.vpower_acc[cnt] =
-	mVPOWER_ACCs(&chip_info->chip_reg_data.meas_regs[offset_reg_data]);
-			} else {
-				/* uni-directional channel */
-				chip_info->chip_reg_data.vpower_acc[cnt] =
-	mVPOWER_ACCu(&chip_info->chip_reg_data.meas_regs[offset_reg_data]);
-			}
-			offset_reg_data += PAC193X_VPOWER_ACC_REG_LEN;
-			/* now compute the scaled to 1 second
-			 * accumulated energy value; see how much shift
-			 * is required by the sample rate
+		/* check if the channel is active, skip all fields if disabled */
+		if (((ctrl_regs_tmp << cnt) & 0x80) == 0) {
+			curr_energy = chip_info->chip_reg_data.energy_sec_acc[cnt];
+			
+			tmp_energy = get_unaligned_be48(offset_reg_data_p);
+			
+			if (chip_info->bi_dir[cnt])
+				reg_data->vpower_acc[cnt] = sign_extend64(tmp_energy, 47);
+			else
+				reg_data->vpower_acc[cnt] = tmp_energy;
+			
+			/*
+			 * compute the scaled to 1 second accumulated energy value;
+			 * energy accumulator scaled to 1sec = VPOWER_ACC/2^samp_shift
+			 * the chip's sampling rate is 2^samp_shift samples/sec
 			 */
-			samp_shift = get_count_order(
-				samp_rate_map_tbl[((
-chip_info->chip_reg_data.ctrl_regs[PAC193X_CTRL_LAT_REG_OFF])>>6)]);
-/* energy accumulator scaled to 1sec = (VPOWER_ACC * ACC_COUNT)/2^samp_shift */
-		/* the chip's sampling rate is 2^samp_shift samples/sec */
-			chip_info->chip_reg_data.energy_sec_acc[cnt] +=
-			(s64)((s64)(chip_info->chip_reg_data.vpower_acc[cnt] *
-			chip_info->chip_reg_data.acc_count) >> samp_shift);
+			inc = (reg_data->vpower_acc[cnt] >> samp_shift);
+			
+			/* add the power_acc field */
+			curr_energy += inc;
+			
+			/* check if we have reached the upper/lower limit */
+			if (curr_energy > (s64)PAC_193X_MAX_POWER_ACC)
+				curr_energy = PAC_193X_MAX_POWER_ACC;
+			else if (curr_energy < ((s64)PAC_193X_MIN_POWER_ACC))
+				curr_energy = PAC_193X_MIN_POWER_ACC;
+			
+			reg_data->energy_sec_acc[cnt] = curr_energy;
+			
+			offset_reg_data_p += PAC193X_VPOWER_ACC_REG_LEN;
 		}
 	}
+	
 	/* continue with VBUS */
 	for (cnt = 0; cnt < chip_info->phys_channels; cnt++) {
-	/* check if the channel is active, skip all fields if disabled */
-		if (((
-chip_info->chip_reg_data.ctrl_regs[PAC193X_CHANNEL_DIS_LAT_REG_OFF] << cnt) &
-			0x80) == 0) {
-			/* read the VBUS channels */
-			chip_info->chip_reg_data.vbus[cnt] =
-	mVBUS_SENSEu(&chip_info->chip_reg_data.meas_regs[offset_reg_data]);
-			offset_reg_data += PAC193X_VBUS_SENSE_REG_LEN;
+		if (((ctrl_regs_tmp << cnt) & 0x80) == 0) {
+			tmp_value = get_unaligned_be16(offset_reg_data_p);
+			
+			if (chip_info->bi_dir[cnt])
+				reg_data->vbus[cnt] = PAC193X_MVBUS_SENSES(tmp_value);
+			else
+				reg_data->vbus[cnt] = tmp_value;
+			
+			offset_reg_data_p += PAC193X_VBUS_SENSE_REG_LEN;
 		}
 	}
+	
 	/* VSENSE */
 	for (cnt = 0; cnt < chip_info->phys_channels; cnt++) {
-	/* check if the channel is active, skip all fields if disabled */
-		if (((
-chip_info->chip_reg_data.ctrl_regs[PAC193X_CHANNEL_DIS_LAT_REG_OFF] << cnt) &
-			0x80) == 0) {
-			/* read the VSENSE registers */
-			if (chip_info->chip_reg_data.bi_dir[cnt]) {
-				/* bi-directional channel */
-				chip_info->chip_reg_data.vsense[cnt] =
-	mVBUS_SENSEs(&chip_info->chip_reg_data.meas_regs[offset_reg_data]);
-			} else {
-				/* uni-directional channel */
-				chip_info->chip_reg_data.vsense[cnt] =
-	mVBUS_SENSEu(&chip_info->chip_reg_data.meas_regs[offset_reg_data]);
-			}
-			offset_reg_data += PAC193X_VBUS_SENSE_REG_LEN;
+		if (((ctrl_regs_tmp << cnt) & 0x80) == 0) {
+			tmp_value = get_unaligned_be16(offset_reg_data_p);
+			
+			if (chip_info->bi_dir[cnt])
+				reg_data->vsense[cnt] = PAC193X_MVBUS_SENSES(tmp_value);
+			else
+				reg_data->vsense[cnt] = tmp_value;
+			
+			offset_reg_data_p += PAC193X_VBUS_SENSE_REG_LEN;
 		}
 	}
+	
 	/* VBUS_AVG */
 	for (cnt = 0; cnt < chip_info->phys_channels; cnt++) {
-	/* check if the channel is active, skip all fields if disabled */
-		if (((
-chip_info->chip_reg_data.ctrl_regs[PAC193X_CHANNEL_DIS_LAT_REG_OFF] << cnt) &
-			0x80) == 0) {
-			/* read the VBUS_AVG registers */
-			chip_info->chip_reg_data.vbus_avg[cnt] =
-	mVBUS_SENSEu(&chip_info->chip_reg_data.meas_regs[offset_reg_data]);
-			offset_reg_data += PAC193X_VBUS_SENSE_REG_LEN;
+		if (((ctrl_regs_tmp << cnt) & 0x80) == 0) {
+			tmp_value = get_unaligned_be16(offset_reg_data_p);
+			
+			if (chip_info->bi_dir[cnt])
+				reg_data->vbus_avg[cnt] = PAC193X_MVBUS_SENSES(tmp_value);
+			else
+				reg_data->vbus_avg[cnt] = tmp_value;
+			
+			offset_reg_data_p += PAC193X_VBUS_SENSE_REG_LEN;
 		}
 	}
+	
 	/* VSENSE_AVG */
 	for (cnt = 0; cnt < chip_info->phys_channels; cnt++) {
-	/* check if the channel is active, skip all fields if disabled */
-		if (((
-chip_info->chip_reg_data.ctrl_regs[PAC193X_CHANNEL_DIS_LAT_REG_OFF] << cnt) &
-			0x80) == 0) {
-			/* read the VSENSE_AVG registers */
-			if (chip_info->chip_reg_data.bi_dir[cnt]) {
-				/* bi-directional channel */
-				chip_info->chip_reg_data.vsense_avg[cnt] =
-	mVBUS_SENSEs(&chip_info->chip_reg_data.meas_regs[offset_reg_data]);
-			} else {
-				/* uni-directional channel */
-				chip_info->chip_reg_data.vsense_avg[cnt] =
-	mVBUS_SENSEu(&chip_info->chip_reg_data.meas_regs[offset_reg_data]);
-			}
-			offset_reg_data += PAC193X_VBUS_SENSE_REG_LEN;
+		if (((ctrl_regs_tmp << cnt) & 0x80) == 0) {
+			tmp_value = get_unaligned_be16(offset_reg_data_p);
+			
+			if (chip_info->bi_dir[cnt])
+				reg_data->vsense_avg[cnt] = PAC193X_MVBUS_SENSES(tmp_value);
+			else
+				reg_data->vsense_avg[cnt] = tmp_value;
+			
+			offset_reg_data_p += PAC193X_VBUS_SENSE_REG_LEN;
 		}
 	}
+	
 	/* VPOWER */
 	for (cnt = 0; cnt < chip_info->phys_channels; cnt++) {
-	/* check if the channel is active, skip all fields if disabled */
-		if (((
-chip_info->chip_reg_data.ctrl_regs[PAC193X_CHANNEL_DIS_LAT_REG_OFF] << cnt) &
-			0x80) == 0) {
-			/* read the VPOWER fields */
-			if (chip_info->chip_reg_data.bi_dir[cnt]) {
-				/* bi-directional channel */
-				chip_info->chip_reg_data.vpower[cnt] =
-	mVPOWERs(&chip_info->chip_reg_data.meas_regs[offset_reg_data]);
-			} else {
-				/* uni-directional channel */
-				chip_info->chip_reg_data.vpower[cnt] =
-	mVPOWERu(&chip_info->chip_reg_data.meas_regs[offset_reg_data]);
-			}
-			offset_reg_data += PAC193X_VPOWER_REG_LEN;
+		if (((ctrl_regs_tmp << cnt) & 0x80) == 0) {
+			tmp = get_unaligned_be32(offset_reg_data_p) >> 4;
+			
+			if (chip_info->bi_dir[cnt])
+				reg_data->vpower[cnt] = sign_extend32(tmp, 27);
+			else
+				reg_data->vpower[cnt] = tmp;
+			
+			offset_reg_data_p += PAC193X_VPOWER_REG_LEN;
 		}
 	}
-reg_snapshot_err:
+	
+	reg_snapshot_err:
 	mutex_unlock(&chip_info->lock);
+	
+	return ret;
+}
+
+static int pac193x_retrieve_data(struct pac193x_chip_info *chip_info,
+								 u32 wait_time)
+{
+	int ret = 0;
+	
+	/*
+	 * check if the minimal elapsed time has passed and if so,
+	 * re-read the chip, otherwise the cached info is just fine
+	 */
+	if (time_after(jiffies, chip_info->jiffies_tstamp +
+		msecs_to_jiffies(PAC193X_MIN_POLLING_TIME_MS))) {
+		ret = pac193x_reg_snapshot(chip_info, true, PAC193X_REFRESH_REG_ADDR,
+								   wait_time);
+		
+		/*
+		 * Re-schedule the work for the read registers on timeout
+		 * (to prevent chip regs saturation)
+		 */
+		cancel_delayed_work_sync(&chip_info->work_chip_rfsh);
+	schedule_delayed_work(&chip_info->work_chip_rfsh,
+						  msecs_to_jiffies(PAC193X_MAX_RFSH_LIMIT_MS));
+		}
+		
+		return ret;
+}
+
+static int pac193x_read_raw(struct iio_dev *indio_dev,
+							struct iio_chan_spec const *chan, int *val,
+							int *val2, long mask)
+{
+	struct pac193x_chip_info *chip_info = iio_priv(indio_dev);
+	s64 curr_energy;
+	int ret, channel = chan->channel - 1;
+	
+	ret = pac193x_retrieve_data(chip_info, PAC193X_MIN_UPDATE_WAIT_TIME_US);
+	if (ret < 0)
+		return ret;
+	
+	switch (mask) {
+		case IIO_CHAN_INFO_RAW:
+			switch (chan->type) {
+				case IIO_VOLTAGE:
+					switch (chan->address) {
+						case PAC193X_VBUS_1_ADDR:
+						case PAC193X_VBUS_2_ADDR:
+						case PAC193X_VBUS_3_ADDR:
+						case PAC193X_VBUS_4_ADDR:
+							*val = chip_info->chip_reg_data.vbus[channel];
+							return IIO_VAL_INT;
+						default:
+							return -EINVAL;
+					}
+					break;
+						case IIO_CURRENT:
+							switch (chan->address) {
+								case PAC193X_VSENSE_1_ADDR:
+								case PAC193X_VSENSE_2_ADDR:
+								case PAC193X_VSENSE_3_ADDR:
+								case PAC193X_VSENSE_4_ADDR:
+									*val = chip_info->chip_reg_data.vsense[channel];
+									return IIO_VAL_INT;
+								default:
+									return -EINVAL;
+							}
+							break;
+								case IIO_POWER:
+									switch (chan->address) {
+										case PAC193X_VPOWER_1_ADDR:
+										case PAC193X_VPOWER_2_ADDR:
+										case PAC193X_VPOWER_3_ADDR:
+										case PAC193X_VPOWER_4_ADDR:
+											*val = chip_info->chip_reg_data.vpower[channel];
+											return IIO_VAL_INT;
+										default:
+											return -EINVAL;
+									}
+									break;
+										case IIO_ENERGY:
+											switch (chan->address) {
+												case PAC193X_VPOWER_ACC_1_ADDR:
+												case PAC193X_VPOWER_ACC_2_ADDR:
+												case PAC193X_VPOWER_ACC_3_ADDR:
+												case PAC193X_VPOWER_ACC_4_ADDR:
+													
+													curr_energy = chip_info->chip_reg_data.energy_sec_acc[channel];
+													*val = (u32)curr_energy;
+													*val2 = (u32)(curr_energy >> 32);
+													return IIO_VAL_INT_64;
+												default:
+													return -EINVAL;
+											}
+											break;
+												default:
+													return -EINVAL;
+			}
+			break;
+												case IIO_CHAN_INFO_AVERAGE_RAW:
+													switch (chan->type) {
+														case IIO_VOLTAGE:
+															switch (chan->address) {
+																case PAC193X_VBUS_AVG_1_ADDR:
+																case PAC193X_VBUS_AVG_2_ADDR:
+																case PAC193X_VBUS_AVG_3_ADDR:
+																case PAC193X_VBUS_AVG_4_ADDR:
+																	*val = chip_info->chip_reg_data.vbus_avg[channel];
+																	return IIO_VAL_INT;
+																	
+																default:
+																	return -EINVAL;
+															}
+															break;
+																case IIO_CURRENT:
+																	switch (chan->address) {
+																		case PAC193X_VSENSE_AVG_1_ADDR:
+																		case PAC193X_VSENSE_AVG_2_ADDR:
+																		case PAC193X_VSENSE_AVG_3_ADDR:
+																		case PAC193X_VSENSE_AVG_4_ADDR:
+																			*val = chip_info->chip_reg_data.vsense_avg[channel];
+																			return IIO_VAL_INT;
+																			
+																		default:
+																			return -EINVAL;
+																	}
+																	break;
+																		default:
+																			return -EINVAL;
+													}
+													break;
+																		case IIO_CHAN_INFO_SCALE:
+																			switch (chan->address) {
+																				/* Voltages - scale for millivolts */
+																				case PAC193X_VBUS_1_ADDR:
+																				case PAC193X_VBUS_2_ADDR:
+																				case PAC193X_VBUS_3_ADDR:
+																				case PAC193X_VBUS_4_ADDR:
+																				case PAC193X_VBUS_AVG_1_ADDR:
+																				case PAC193X_VBUS_AVG_2_ADDR:
+																				case PAC193X_VBUS_AVG_3_ADDR:
+																				case PAC193X_VBUS_AVG_4_ADDR:
+																					*val = PAC193X_VOLTAGE_MILLIVOLTS_MAX;
+																					if (chan->scan_type.sign == 'u')
+																						*val2 = PAC193X_VOLTAGE_U_RES;
+																				else
+																					*val2 = PAC193X_VOLTAGE_S_RES;
+																				return IIO_VAL_FRACTIONAL_LOG2;
+																				
+																				/*
+																				 * Currents - scale for mA - depends on the
+																				 * channel's shunt value
+																				 * (100mV * 1000000) / (2^16 * shunt(uohm))
+																				 */
+																				case PAC193X_VSENSE_1_ADDR:
+																				case PAC193X_VSENSE_2_ADDR:
+																				case PAC193X_VSENSE_3_ADDR:
+																				case PAC193X_VSENSE_4_ADDR:
+																				case PAC193X_VSENSE_AVG_1_ADDR:
+																				case PAC193X_VSENSE_AVG_2_ADDR:
+																				case PAC193X_VSENSE_AVG_3_ADDR:
+																				case PAC193X_VSENSE_AVG_4_ADDR:
+																					*val = PAC193X_MAX_VSENSE_RSHIFTED_BY_16B;
+																					if (chan->scan_type.sign == 'u')
+																						*val2 = chip_info->shunts[channel];
+																				else
+																					*val2 = chip_info->shunts[channel] >> 1;
+																				return IIO_VAL_FRACTIONAL;
+																				
+																				/*
+																				 * Power - uW - it will use the combined scale
+																				 * for current and voltage
+																				 * current(mA) * voltage(mV) = power (uW)
+																				 */
+																				case PAC193X_VPOWER_1_ADDR:
+																				case PAC193X_VPOWER_2_ADDR:
+																				case PAC193X_VPOWER_3_ADDR:
+																				case PAC193X_VPOWER_4_ADDR:
+																					*val = PAC193X_MAX_VPOWER_RSHIFTED_BY_28B;
+																					if (chan->scan_type.sign == 'u')
+																						*val2 = chip_info->shunts[channel];
+																				else
+																					*val2 = chip_info->shunts[channel] >> 1;
+																				return IIO_VAL_FRACTIONAL;
+																				case PAC193X_VPOWER_ACC_1_ADDR:
+																				case PAC193X_VPOWER_ACC_2_ADDR:
+																				case PAC193X_VPOWER_ACC_3_ADDR:
+																				case PAC193X_VPOWER_ACC_4_ADDR:
+																					
+																					/*
+																					 * expresses the 32 bit scale value
+																					 * here compute the scale for energy (mili Watt-second or miliJoule)
+																					 */
+																					*val = PAC193X_SCALE_CONSTANT;
+																					
+																					if (chan->scan_type.sign == 'u')
+																						*val2 = chip_info->shunts[channel];
+																				else
+																					*val2 = chip_info->shunts[channel] >> 1;
+																				return IIO_VAL_FRACTIONAL;
+																				default:
+																					return -EINVAL;
+																			}
+																			break;
+																				case IIO_CHAN_INFO_SAMP_FREQ:
+																					*val = chip_info->sample_rate_value;
+																					return IIO_VAL_INT;
+																				default:
+																					return -EINVAL;
+	}
+	
+	return -EINVAL;
+}
+
+static int pac193x_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,
+							 int val, int val2, long mask)
+{
+	struct pac193x_chip_info *chip_info = iio_priv(indio_dev);
+	struct i2c_client *client = chip_info->client;
+	int ret = -EINVAL;
+	s32 old_samp_rate;
+	u8 ctrl_reg;
+	
+	switch (mask) {
+		case IIO_CHAN_INFO_SAMP_FREQ:
+			ret = pac193x_match_samp_rate(chip_info, (u16)val);
+			if (ret)
+				return ret;
+		
+		old_samp_rate = chip_info->sample_rate_value;
+		chip_info->sample_rate_value = val;
+		
+		/*
+		 * now lock the access to the chip, write the new
+		 * sampling value and trigger a snapshot(incl refresh)
+		 */
+		mutex_lock(&chip_info->lock);
+		
+		ctrl_reg = PAC193X_CRTL_SAMPLE_RATE_SET(chip_info->crt_samp_spd_bitfield);
+		ret = i2c_smbus_write_byte_data(client, PAC193X_CTRL_REG_ADDR, ctrl_reg);
+		if (ret) {
+			dev_err(&client->dev, "%s - can't update sample rate\n", __func__);
+			chip_info->sample_rate_value = old_samp_rate;
+			mutex_unlock(&chip_info->lock);
+			return ret;
+		}
+		
+		/*
+		 * unlock the access towards the chip - register
+		 * snapshot includes its own access lock
+		 */
+		mutex_unlock(&chip_info->lock);
+		
+		/*
+		 * now, force a snapshot with refresh - call retrieve
+		 * data in order to update the refresh timer
+		 * alter the timestamp in order to force trigger a
+		 * register snapshot and a timestamp update
+		 */
+		chip_info->jiffies_tstamp -=
+		msecs_to_jiffies(PAC193X_MIN_POLLING_TIME_MS);
+		ret = pac193x_retrieve_data(chip_info, (1024 / old_samp_rate) * 1000);
+		if (ret < 0) {
+			dev_err(&client->dev,
+					"%s - cannot snapshot ctrl and measurement regs\n",
+		   __func__);
+			return ret;
+		}
+		
+		ret = 0;
+		break;
+		default:
+			break;
+	}
+	
 	return ret;
 }
 
 static void pac193x_work_periodic_rfsh(struct work_struct *work)
 {
-	struct pac193x_chip_info *chip_info = to_pac193x_chip_info(work);
-	int ret;
+	struct pac193x_chip_info *chip_info = TO_PAC193X_CHIP_INFO((struct delayed_work *)work);
+	struct i2c_client *client = chip_info->client;
+	
+	dev_dbg(&client->dev, "%s - Periodic refresh\n", __func__);
+	
 	/* do a REFRESH, then read */
-	ret = pac193x_reg_snapshot(chip_info, true, false,
-			PAC193x_MIN_UPDATE_WAIT_TIME);
+	pac193x_reg_snapshot(chip_info, true, PAC193X_REFRESH_REG_ADDR,
+						 PAC193X_MIN_UPDATE_WAIT_TIME_US);
+	
+	schedule_delayed_work(&chip_info->work_chip_rfsh,
+						  msecs_to_jiffies(PAC193X_MAX_RFSH_LIMIT_MS));
 }
 
-//void pac193x_read_reg_timeout(unsigned long arg)
-void pac193x_read_reg_timeout(struct timer_list *t)
+static int pac193x_read_revision(struct pac193x_chip_info *chip_info, u8 *buf)
 {
 	int ret;
-	//struct pac193x_chip_info *chip_info = (struct pac193x_chip_info *)arg;
-	struct pac193x_chip_info *chip_info = from_timer(chip_info, t, tmr_forced_update);
 	struct i2c_client *client = chip_info->client;
-
-	ret = mod_timer(&chip_info->tmr_forced_update,
-		jiffies + msecs_to_jiffies(PAC193X_MAX_RFSH_LIMIT));
-	if (ret < 0)
-		dev_err(&client->dev,
-			"forced read timer cannot be modified!\n");
-	/* schedule the periodic reading from the chip */
-	queue_work(chip_info->wq_chip, &chip_info->work_chip_rfsh);
+	
+	ret = pac193x_i2c_read(client, PAC193X_PID_REG_ADDR, buf, PAC193X_ID_REG_LEN);
+	if (ret) {
+		dev_err(&client->dev, "cannot read revision\n");
+		return ret;
+	}
+	
+	return 0;
 }
 
 static int pac193x_chip_identify(struct pac193x_chip_info *chip_info)
 {
-	int ret = 0;
+	int ret;
 	struct i2c_client *client = chip_info->client;
-	u8 chip_rev_info[3];
-	/*try to identify the chip variant
-	 * read the chip ID values
-	 */
-	ret = pac193x_i2c_read(chip_info->client, PAC193X_PID_REG_ADDR,
-				(u8 *) chip_rev_info, 3);
-	if (ret < 0) {
-		dev_err(&client->dev, "cannot read PAC193x revision\n");
-		goto chip_identify_err;
+	u8 rev_info[PAC193X_ID_REG_LEN];
+	
+	ret = pac193x_read_revision(chip_info, (u8 *)rev_info);
+	if (ret) {
+		dev_err_probe(&client->dev, ret, "cannot read revision\n");
+		return ret;
 	}
-	if (chip_rev_info[0] !=
-		pac193x_chip_config[chip_info->chip_variant].prod_id) {
-		ret = -EINVAL;
-		dev_err(&client->dev,
-"chip's product ID doesn't match the exact one for this part\n");
-		goto chip_identify_err;
+	
+	if (rev_info[PAC193X_PID_IDX] != pac193x_chip_config[chip_info->chip_variant].prod_id) {
+		dev_err_probe(&client->dev, ret,
+					  "chip's product ID doesn't match the exact one for this part %d:%d\n",
+				rev_info[PAC193X_PID_IDX],
+				pac193x_chip_config[chip_info->chip_variant].prod_id);
+		return -EINVAL;
 	}
-	dev_info(&client->dev, "Chip revision: 0x%02X\n", chip_rev_info[2]);
-	chip_info->chip_revision = chip_rev_info[2];
-chip_identify_err:
-	return ret;
+	
+	dev_dbg(&client->dev, "Chip revision: 0x%02X\n", rev_info[PAC193X_RID_IDX]);
+	chip_info->chip_revision = rev_info[PAC193X_RID_IDX];
+	
+	return 0;
 }
 
-static int pac193x_setup_periodic_refresh(struct pac193x_chip_info *chip_info)
+static int pac193x_get_variant(struct pac193x_chip_info *chip_info)
 {
-	int ret = 0;
-
-	chip_info->wq_chip = create_workqueue("wq_pac193x");
-	INIT_WORK(&chip_info->work_chip_rfsh, pac193x_work_periodic_rfsh);
-
-	/* setup the latest moment for reading the regs before saturation */
-	 //init_timer(&chip_info->tmr_forced_update);
-	/* register the timer */
-	//chip_info->tmr_forced_update.data = (unsigned long)chip_info;
-	//chip_info->tmr_forced_update.function = pac193x_read_reg_timeout;
-	timer_setup(&chip_info->tmr_forced_update, pac193x_read_reg_timeout, 0); //(unsigned long)chip_info);
-	chip_info->tmr_forced_update.expires = jiffies +
-			msecs_to_jiffies(PAC193X_MAX_RFSH_LIMIT);
-	chip_info->forced_reads_triggered = 0;
-	add_timer(&chip_info->tmr_forced_update);
-
-	return ret;
+	u8 rev_info[PAC193X_ID_REG_LEN];
+	int ret;
+	
+	ret = pac193x_read_revision(chip_info, (u8 *)rev_info);
+	if (!ret) {
+		chip_info->chip_variant = rev_info[PAC193X_PID_IDX];
+		chip_info->chip_revision = rev_info[PAC193X_RID_IDX];
+		switch (chip_info->chip_variant) {
+			case PAC1934_PID:
+				chip_info->phys_channels = PAC1934_NUM_CHANNELS;
+				break;
+			case PAC1933_PID:
+				chip_info->phys_channels = PAC1933_NUM_CHANNELS;
+				break;
+			case PAC1932_PID:
+				chip_info->phys_channels = PAC1932_NUM_CHANNELS;
+				break;
+			case PAC1931_PID:
+				chip_info->phys_channels = PAC1931_NUM_CHANNELS;
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+	
+	return 0;
 }
 
-static const char *pac193x_match_of_device(struct i2c_client *client,
-					struct pac193x_chip_info *chip_info)
+/*
+ * documentation related to the ACPI device definition
+ * https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ApplicationNotes/ApplicationNotes/PAC193X-Integration-Notes-for-Microsoft-Windows-10-and-Windows-11-Driver-Support-DS00002534.pdf
+ */
+static union acpi_object *pac193x_acpi_eval_function(acpi_handle handle,
+													 int revision,
+													 int function)
 {
-	struct device_node *node;
-	unsigned int crt_ch;
-	const char *ptr_name;
+	acpi_status status;
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object args[PAC193X_ACPI_ARG_COUNT];
+	struct acpi_object_list args_list;
+	uuid_t uuid;
+	
+	uuid_parse(PAC193X_DSM_UUID, &uuid);
+	
+	args[0].type = ACPI_TYPE_BUFFER;
+	args[0].buffer.length = sizeof(uuid_t);
+	args[0].buffer.pointer = (u8 *)&uuid;
+	
+	args[1].type = ACPI_TYPE_INTEGER;
+	args[1].integer.value = revision;
+	
+	args[2].type = ACPI_TYPE_INTEGER;
+	args[2].integer.value = function;
+	
+	args[3].type = ACPI_TYPE_PACKAGE;
+	args[3].package.count = 0;
+	
+	args_list.count = PAC193X_ACPI_ARG_COUNT;
+	args_list.pointer = &args[0];
+	
+	status = acpi_evaluate_object(handle, "_DSM", &args_list, &buffer);
+	
+	if (ACPI_FAILURE(status)) {
+		kfree(buffer.pointer);
+		return NULL;
+	}
+	
+	return buffer.pointer;
+}
 
-	ptr_name = pac193x_get_of_match_entry(client);
+static char *pac193x_acpi_get_acpi_match_entry(acpi_handle handle)
+{
+	acpi_status status;
+	union acpi_object *name_object;
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	
+	status = acpi_evaluate_object(handle, "_HID", NULL, &buffer);
+	name_object = buffer.pointer;
+	
+	return name_object->string.pointer;
+}
 
-	if (of_property_read_u32(client->dev.of_node, "samp-rate",
-				&chip_info->sample_rate_value)) {
-		dev_err(&client->dev, "Cannot read sample rate value ...\n");
+static const char *pac193x_match_acpi_device(struct i2c_client *client,
+											 struct pac193x_chip_info *chip_info)
+{
+	char *name;
+	acpi_handle handle;
+	union acpi_object *rez;
+	unsigned short bi_dir_mask;
+	int idx, i;
+	
+	handle = ACPI_HANDLE(&client->dev);
+	name = pac193x_acpi_get_acpi_match_entry(handle);
+	if (!name)
 		return NULL;
-	}
-	if (pac193x_match_samp_rate(chip_info, chip_info->sample_rate_value)) {
-		dev_err(&client->dev,
-			"The given sample rate value is not supported: %d\n",
-			chip_info->sample_rate_value);
+	
+	rez = pac193x_acpi_eval_function(handle, 0, PAC193X_ACPI_GET_NAMES_AND_MOHMS_VALS);
+	
+	if (!rez)
 		return NULL;
+	
+	for (i = 0; i < rez->package.count; i += 2) {
+		idx = i / 2;
+		chip_info->channel_names[idx] =
+		devm_kmemdup(&client->dev, rez->package.elements[i].string.pointer,
+					 (size_t)rez->package.elements[i].string.length + 1,
+					 GFP_KERNEL);
+		chip_info->channel_names[idx][rez->package.elements[i].string.length] = '\0';
+		chip_info->shunts[idx] =
+		rez->package.elements[i + 1].integer.value * 1000;
+		chip_info->active_channels[idx] = (chip_info->shunts[idx] != 0);
 	}
-	crt_ch = 0;
-	for_each_child_of_node(client->dev.of_node, node) {
-		if (crt_ch >= chip_info->phys_channels)
-			return NULL;
-		/* check if the channel is enabled or not */
-		chip_info->chip_reg_data.active_channels[crt_ch] =
-			of_property_read_bool(node, "channel_enabled");
-		if (!chip_info->chip_reg_data.active_channels[crt_ch]) {
-		/* set the chunt value to 0 for the disabled channels */
-			chip_info->shunts[crt_ch] = 0;
-			crt_ch++;
-			continue;
-		}
-		if (of_property_read_u32(node,
-			"uohms-shunt-res", &chip_info->shunts[crt_ch])) {
-			dev_err(&client->dev,
-				"invalid shunt-resistor value on %s\n",
-				node->full_name);
-			return NULL;
+	
+	kfree(rez);
+	
+	rez = pac193x_acpi_eval_function(handle, 1, PAC193X_ACPI_GET_UOHMS_VALS);
+	if (!rez) {
+		/*
+		 * initializing with default values
+		 * we assume all channels are unidirectional(the mask is zero)
+		 * and assign the default sampling rate
+		 */
+		chip_info->sample_rate_value = PAC193X_DEFAULT_CHIP_SAMP_SPEED;
+		return name;
+	}
+	
+	for (i = 0; i < rez->package.count; i++) {
+		idx = i;
+		chip_info->shunts[idx] = rez->package.elements[i].integer.value;
+		chip_info->active_channels[idx] = (chip_info->shunts[idx] != 0);
+	}
+	
+	kfree(rez);
+	
+	rez = pac193x_acpi_eval_function(handle, 1, PAC193X_ACPI_GET_BIPOLAR_SETTINGS);
+	if (!rez)
+		return NULL;
+	
+	bi_dir_mask = rez->package.elements[0].integer.value;
+	chip_info->bi_dir[0] = ((bi_dir_mask & (1 << 3)) | (bi_dir_mask & (1 << 7))) != 0;
+	chip_info->bi_dir[1] = ((bi_dir_mask & (1 << 2)) | (bi_dir_mask & (1 << 6))) != 0;
+	chip_info->bi_dir[2] = ((bi_dir_mask & (1 << 1)) | (bi_dir_mask & (1 << 5))) != 0;
+	chip_info->bi_dir[3] = ((bi_dir_mask & (1 << 0)) | (bi_dir_mask & (1 << 4))) != 0;
+	
+	kfree(rez);
+	
+	rez = pac193x_acpi_eval_function(handle, 1, PAC193X_ACPI_GET_SAMP);
+	if (!rez)
+		return NULL;
+	
+	chip_info->sample_rate_value = rez->package.elements[0].integer.value;
+	kfree(rez);
+	
+	return name;
+}
+
+static const struct of_device_id pac193x_of_match[] = {
+	{
+		.compatible = "microchip,pac1931",
+		.data = &pac193x_chip_config[PAC1931]
+	},
+	{
+		.compatible = "microchip,pac1932",
+		.data = &pac193x_chip_config[PAC1932]
+	},
+	{
+		.compatible = "microchip,pac1933",
+		.data = &pac193x_chip_config[PAC1933]
+	},
+	{
+		.compatible = "microchip,pac1934",
+		.data = &pac193x_chip_config[PAC1934]
+	},
+	{}
+};
+
+static int pac193x_match_of_device(struct i2c_client *client,
+								   struct pac193x_chip_info *chip_info)
+{
+	struct fwnode_handle *node, *fwnode;
+	unsigned int current_channel;
+	int idx, ret;
+	
+	chip_info->sample_rate_value = 1024;
+	current_channel = 1;
+	
+	fwnode = dev_fwnode(&client->dev);
+	fwnode_for_each_available_child_node(fwnode, node) {
+		ret = fwnode_property_read_u32(node, "reg", &idx);
+		if (ret) {
+			dev_err_probe(&client->dev, ret,
+						  "reading invalid channel index\n");
+			fwnode_handle_put(node);
+			return ret;
 		}
-		chip_info->chip_reg_data.bi_dir[crt_ch] =
-				of_property_read_bool(node, "bi-dir");
-		/* increment the channel index */
-		crt_ch++;
+		/* adjust idx to match channel index (1 to 4) from the datasheet */
+		idx--;
+		if (current_channel >= (chip_info->phys_channels + 1) ||
+			idx >= chip_info->phys_channels || idx < 0) {
+			dev_err_probe(&client->dev, -EINVAL,
+						  "%s: invalid channel_index %d value\n",
+				 fwnode_get_name(node), idx);
+			fwnode_handle_put(node);
+		return -EINVAL;
+			}
+			
+			/* enable channel */
+			chip_info->active_channels[idx] = true;
+			
+			ret = fwnode_property_read_u32(node, "shunt-resistor-micro-ohms",
+										   &chip_info->shunts[idx]);
+			if (ret) {
+				dev_err_probe(&client->dev, ret,
+							  "%s: invalid shunt-resistor value: %d\n",
+				  fwnode_get_name(node), chip_info->shunts[idx]);
+				fwnode_handle_put(node);
+				return ret;
+			}
+			
+			ret = fwnode_property_read_string(node, "label",
+											  (const char **)&chip_info->channel_names[idx]);
+			if (ret) {
+				dev_err_probe(&client->dev, ret,
+							  "%s: invalid rail-name value\n",
+				  fwnode_get_name(node));
+				fwnode_handle_put(node);
+				return ret;
+			}
+			
+			chip_info->bi_dir[idx] =
+			fwnode_property_read_bool(node, "bipolar");
+			
+			current_channel++;
 	}
-	return ptr_name;
+	
+	return 0;
 }
 
 static int pac193x_chip_configure(struct pac193x_chip_info *chip_info)
 {
-	int cnt, ret = 0;
+	int cnt, ret;
 	struct i2c_client *client = chip_info->client;
-	u8 regs[PAC193X_CTRL_STATUS_INFO_LEN];
+	u8 regs[PAC193X_CTRL_STATUS_INFO_LEN], idx, ctrl_reg;
 	u32 wait_time;
-
-	/* count how many channels are enabled and store
-	 * this information within the driver data
-	 */
+	
 	cnt = 0;
 	chip_info->chip_reg_data.num_enabled_channels = 0;
 	while (cnt < chip_info->phys_channels) {
-		if (chip_info->chip_reg_data.active_channels[cnt])
+		if (chip_info->active_channels[cnt])
 			chip_info->chip_reg_data.num_enabled_channels++;
 		cnt++;
 	}
-	/* read whatever information was gathered before the driver was loaded
+	
+	/*
+	 * read whatever information was gathered before the driver was loaded
 	 * establish which channels are enabled/disabled and then establish the
 	 * information retrieval mode (using SKIP or no).
 	 * Read the chip ID values
 	 */
-	ret = pac193x_i2c_read(chip_info->client, PAC193X_CTRL_STAT_REGS_ADDR,
-				(u8 *)regs, PAC193X_CTRL_STATUS_INFO_LEN);
-	if (ret < 0) {
-		dev_err(&client->dev,
-				"%s - cannot read PAC193x regs from 0x%02X\n",
+	ret = pac193x_i2c_read(client, PAC193X_CTRL_STAT_REGS_ADDR,
+						   (u8 *)regs, sizeof(regs));
+	if (ret) {
+		dev_err_probe(&client->dev, ret,
+					  "%s - cannot read regs from 0x%02X\n",
 				__func__, PAC193X_CTRL_STAT_REGS_ADDR);
-		goto chip_configure_err;
+		return ret;
 	}
+	
 	/* write the CHANNEL_DIS and the NEG_PWR registers */
 	regs[PAC193X_CHANNEL_DIS_REG_OFF] =
-		CHANNEL_DIS_REG(chip_info->chip_reg_data.active_channels[0],
-				chip_info->chip_reg_data.active_channels[1],
-				chip_info->chip_reg_data.active_channels[2],
-				chip_info->chip_reg_data.active_channels[3],
-				0, 0, 1);
-
+	PAC193X_CHAN_DIS_CH1_OFF(chip_info->active_channels[PAC193X_CH_1]) |
+	PAC193X_CHAN_DIS_CH2_OFF(chip_info->active_channels[PAC193X_CH_2]) |
+	PAC193X_CHAN_DIS_CH3_OFF(chip_info->active_channels[PAC193X_CH_3]) |
+	PAC193X_CHAN_DIS_CH4_OFF(chip_info->active_channels[PAC193X_CH_4]) |
+	PAC193X_SMBUS_TIMEOUT_EN(0) |
+	PAC193X_SMBUS_BYTECOUNT_EN(0) |
+	PAC193X_SMBUS_NO_SKIP_EN(0);
+	
 	regs[PAC193X_NEG_PWR_REG_OFF] =
-		NEG_PWR_REG(chip_info->chip_reg_data.bi_dir[0],
-			chip_info->chip_reg_data.bi_dir[1],
-			chip_info->chip_reg_data.bi_dir[2],
-			chip_info->chip_reg_data.bi_dir[3],
-			0, 0, 0, 0);
-	/* the current can be measured uni or bi-dir, but voltages are set only
-	 * for uni-directional operation
-	 * no SLOW triggered REFRESH, clear POR
-	 */
+	PAC193X_NEG_PWR_CH1_BIDI(chip_info->bi_dir[PAC193X_CH_1]) |
+	PAC193X_NEG_PWR_CH2_BIDI(chip_info->bi_dir[PAC193X_CH_2]) |
+	PAC193X_NEG_PWR_CH3_BIDI(chip_info->bi_dir[PAC193X_CH_3]) |
+	PAC193X_NEG_PWR_CH4_BIDI(chip_info->bi_dir[PAC193X_CH_4]) |
+	PAC193X_NEG_PWR_CH1_BIDV(chip_info->bi_dir[PAC193X_CH_1]) |
+	PAC193X_NEG_PWR_CH2_BIDV(chip_info->bi_dir[PAC193X_CH_2]) |
+	PAC193X_NEG_PWR_CH3_BIDV(chip_info->bi_dir[PAC193X_CH_3]) |
+	PAC193X_NEG_PWR_CH4_BIDV(chip_info->bi_dir[PAC193X_CH_4]);
+	
+	/* no SLOW triggered REFRESH, clear POR */
 	regs[PAC193X_SLOW_REG_OFF] = 0;
-	/* write the updated registers back */
-	ret = pac193x_i2c_write(chip_info->client, PAC193X_CTRL_STAT_REGS_ADDR,
-				3, (u8 *)regs);
-	if (ret < 0) {
-		dev_err(&client->dev,
-				"%s - cannot write PAC193x regs from 0x%02X\n",
-				__func__, PAC193X_CHANNEL_DIS_REG_OFF);
-		goto chip_configure_err;
-	}
-	/* enable the ALERT pin functionality */
-	ret = pac193x_i2c_write_byte(chip_info->client, PAC193X_CTRL_REG,
-		CTRL_REG(chip_info->chip_reg_data.crt_samp_speed_bitfield,
-		0, 0, 1, 0, 0));
-	if (ret < 0) {
-		dev_err(&client->dev,
-			"%s - cannot write PAC193x ctrl reg at 0x%02X\n",
-			__func__, PAC193X_CTRL_REG);
-		goto chip_configure_err;
-	}
-	/* send a REFRESH to the chip, so the new settings take place
-	 * as well as reseting the accumulators
+	
+	ret = pac193x_i2c_write(client, PAC193X_CTRL_STAT_REGS_ADDR, (u8 *)regs, 3);
+	if (ret)
+		return ret;
+	
+	ctrl_reg = PAC193X_CRTL_SAMPLE_RATE_SET(chip_info->crt_samp_spd_bitfield);
+	ret = i2c_smbus_write_byte_data(client, PAC193X_CTRL_REG_ADDR, ctrl_reg);
+	if (ret)
+		return ret;
+	
+	/*
+	 * send a REFRESH to the chip, so the new settings take place
+	 * as well as resetting the accumulators
 	 */
-	ret = pac193x_i2c_send_byte(chip_info->client, PAC193X_REFRESH_REG);
-	if (ret < 0) {
+	ret = i2c_smbus_write_byte(client, PAC193X_REFRESH_REG_ADDR);
+	if (ret) {
 		dev_err(&client->dev,
-				"%s - cannot send byte to PAC193x 0x%02X reg\n",
-				__func__, PAC193X_REFRESH_REG);
+				"%s - cannot send 0x%02X\n",
+		  __func__, PAC193X_REFRESH_REG_ADDR);
 		return ret;
 	}
-
-	/* get the current(in the chip) sampling speed and compute the
+	
+	/*
+	 * get the current(in the chip) sampling speed and compute the
 	 * required timeout based on its value
 	 * the timeout is 1/sampling_speed
 	 */
-	wait_time = (1024 /
-		samp_rate_map_tbl[(regs[PAC193X_CTRL_ACT_REG_OFF]>>6)]) * 1000;
-	/* wait the maximum amount of time to be on the safe side - the
-	 * maximum wait time is for 8sps
+	idx = regs[PAC193X_CTRL_ACT_REG_OFF] >> PAC193X_SAMPLE_RATE_SHIFT;
+	wait_time = (1024 / samp_rate_map_tbl[idx]) * 1000;
+	
+	/*
+	 * wait the maximum amount of time to be on the safe side
+	 * the maximum wait time is for 8sps
 	 */
 	usleep_range(wait_time, wait_time + 100);
-	/* setup the refresh timeout */
-	ret = pac193x_setup_periodic_refresh(chip_info);
-chip_configure_err:
-	return ret;
-}
-
-static int pac193x_retrieve_data(struct pac193x_chip_info *chip_info,
-					u32 wait_time)
-{
-	int ret = 0;
-	struct i2c_client *client = chip_info->client;
-	/* check if the minimal elapsed time has passed and if so,
-	 * re-read the chip, otherwise the cached info is just fine
-	 */
-	if (time_after(jiffies, chip_info->chip_reg_data.jiffies_tstamp +
-		msecs_to_jiffies(PAC193X_MIN_POLLING_TIME))) {
-		/* we need to re-read the chip values
-		 * call the pac193x_reg_snapshot
-		 */
-		ret = pac193x_reg_snapshot(chip_info, true, false, wait_time);
-		/* re-schedule the work for the read registers timeout
-		 * (to prevent chip regs saturation)
-		 */
-		ret = mod_timer(&chip_info->tmr_forced_update,
-			chip_info->chip_reg_data.jiffies_tstamp +
-			msecs_to_jiffies(PAC193X_MAX_RFSH_LIMIT));
-		if (ret < 0)
-			dev_err(&client->dev,
-				"forced read timer cannot be modified!\n");
-	}
-	return ret;
+	
+	INIT_DELAYED_WORK(&chip_info->work_chip_rfsh, pac193x_work_periodic_rfsh);
+	/* Setup the latest moment for reading the regs before saturation */
+	schedule_delayed_work(&chip_info->work_chip_rfsh,
+						  msecs_to_jiffies(PAC193X_MAX_RFSH_LIMIT_MS));
+	
+	return 0;
 }
 
-static int pac193x_prep_iio_channels(struct pac193x_chip_info *chip_info,
-					struct iio_dev *indio_dev)
+static int pac193x_prep_iio_channels(struct pac193x_chip_info *chip_info, struct iio_dev *indio_dev)
 {
 	struct i2c_client *client;
 	struct iio_chan_spec *ch_sp;
-	int channel_size, active_num_chan, total_iio_chan;
-	int cnt;
+	int channel_size, attribute_count, cnt;
 	void *dyn_ch_struct, *tmp_data;
-
+	
 	client = chip_info->client;
+	
 	/* find out dynamically how many IIO channels we need */
-	active_num_chan = 0;
+	attribute_count = 0;
 	channel_size = 0;
 	for (cnt = 0; cnt < chip_info->phys_channels; cnt++) {
-		if (chip_info->chip_reg_data.active_channels[cnt]) {
-	/* add the size of the properties of one chip physical channel */
+		if (chip_info->active_channels[cnt]) {
+			/* add the size of the properties of one chip physical channel */
 			channel_size += sizeof(pac193x_single_channel);
 			/* count how many enabled channels we have */
-			active_num_chan += ARRAY_SIZE(pac193x_single_channel);
-			dev_info(&client->dev,
-				":%s: Channel %d active\n", __func__, cnt);
+			attribute_count += ARRAY_SIZE(pac193x_single_channel);
+			dev_info(&client->dev, ":%s: Channel %d active\n", __func__, cnt + 1);
 		}
 	}
-	/* now add the timestamp channel size */
-	channel_size += sizeof(pac193x_ts);
-	/* add one more channel which is the timestamp */
-	total_iio_chan = active_num_chan + 1;
-
-	dev_info(&client->dev,
-		":%s: Active chip channels: %d\n", __func__, total_iio_chan);
-
+	
 	dyn_ch_struct = kzalloc(channel_size, GFP_KERNEL);
 	if (!dyn_ch_struct)
 		return -EINVAL;
-
+	
 	tmp_data = dyn_ch_struct;
+	
 	/* populate the dynamic channels and make all the adjustments */
 	for (cnt = 0; cnt < chip_info->phys_channels; cnt++) {
-		if (chip_info->chip_reg_data.active_channels[cnt]) {
-			memcpy(tmp_data, pac193x_single_channel,
-				sizeof(pac193x_single_channel));
+		if (chip_info->active_channels[cnt]) {
+			memcpy(tmp_data, pac193x_single_channel, sizeof(pac193x_single_channel));
 			ch_sp = (struct iio_chan_spec *)tmp_data;
-			ch_sp[IIO_EN].channel = cnt;
+			ch_sp[IIO_EN].channel = cnt + 1;
 			ch_sp[IIO_EN].scan_index = cnt;
-			ch_sp[IIO_EN].address = cnt+
-						PAC193X_VPOWER_ACC_0_ADDR;
-			ch_sp[IIO_POW].channel = cnt;
+			ch_sp[IIO_EN].address = cnt + PAC193X_VPOWER_ACC_1_ADDR;
+			ch_sp[IIO_POW].channel = cnt + 1;
 			ch_sp[IIO_POW].scan_index = cnt;
-			ch_sp[IIO_POW].address = cnt+
-						PAC193X_VPOWER_0_ADDR;
-			ch_sp[IIO_VOLT].channel = cnt;
+			ch_sp[IIO_POW].address = cnt + PAC193X_VPOWER_1_ADDR;
+			ch_sp[IIO_VOLT].channel = cnt + 1;
 			ch_sp[IIO_VOLT].scan_index = cnt;
-			ch_sp[IIO_VOLT].address = cnt+
-						PAC193X_VBUS_0_ADDR;
-			ch_sp[IIO_CRT].channel = cnt;
+			ch_sp[IIO_VOLT].address = cnt + PAC193X_VBUS_1_ADDR;
+			ch_sp[IIO_CRT].channel = cnt + 1;
 			ch_sp[IIO_CRT].scan_index = cnt;
-			ch_sp[IIO_CRT].address = cnt+
-						PAC193X_VSENSE_0_ADDR;
-			ch_sp[IIO_VOLTAVG].channel = cnt;
+			ch_sp[IIO_CRT].address = cnt + PAC193X_VSENSE_1_ADDR;
+			ch_sp[IIO_VOLTAVG].channel = cnt + 1;
 			ch_sp[IIO_VOLTAVG].scan_index = cnt;
-			ch_sp[IIO_VOLTAVG].address = cnt+
-						PAC193X_VBUS_AVG_0_ADDR;
-			ch_sp[IIO_CRTAVG].channel = cnt;
+			ch_sp[IIO_VOLTAVG].address = cnt + PAC193X_VBUS_AVG_1_ADDR;
+			ch_sp[IIO_CRTAVG].channel = cnt + 1;
 			ch_sp[IIO_CRTAVG].scan_index = cnt;
-			ch_sp[IIO_CRTAVG].address = cnt+
-						PAC193X_VSENSE_AVG_0_ADDR;
-			/* now modify the parameters in all channels if the
+			ch_sp[IIO_CRTAVG].address = cnt + PAC193X_VSENSE_AVG_1_ADDR;
+			
+			/*
+			 * now modify the parameters in all channels if the
 			 * whole chip rail(channel) is bi-directional
 			 */
-			if (chip_info->chip_reg_data.bi_dir[cnt]) {
-				ch_sp[IIO_EN].scan_type.sign =
-					's';
-				ch_sp[IIO_EN].scan_type.realbits =
-					PAC193X_ENERGY_S_RES;
-				ch_sp[IIO_POW].scan_type.sign =
-					's';
-				ch_sp[IIO_POW].scan_type.realbits =
-					PAC193X_POWER_S_RES;
-				ch_sp[IIO_VOLT].scan_type.sign =
-					's';
-				ch_sp[IIO_VOLT].scan_type.realbits =
-					PAC193X_VOLTAGE_S_RES;
-				ch_sp[IIO_CRT].scan_type.sign =
-					's';
-				ch_sp[IIO_CRT].scan_type.realbits =
-					PAC193X_CURRENT_S_RES;
-				ch_sp[IIO_VOLTAVG].scan_type.sign =
-					's';
-				ch_sp[IIO_VOLTAVG].scan_type.realbits =
-					PAC193X_VOLTAGE_S_RES;
-				ch_sp[IIO_CRTAVG].scan_type.sign =
-					's';
-				ch_sp[IIO_CRTAVG].scan_type.realbits =
-					PAC193X_CURRENT_S_RES;
+			if (chip_info->bi_dir[cnt]) {
+				ch_sp[IIO_EN].scan_type.sign = 's';
+				ch_sp[IIO_EN].scan_type.realbits = PAC193X_ENERGY_S_RES;
+				ch_sp[IIO_POW].scan_type.sign = 's';
+				ch_sp[IIO_POW].scan_type.realbits = PAC193X_POWER_S_RES;
+				ch_sp[IIO_VOLT].scan_type.sign = 's';
+				ch_sp[IIO_VOLT].scan_type.realbits = PAC193X_VOLTAGE_S_RES;
+				ch_sp[IIO_CRT].scan_type.sign = 's';
+				ch_sp[IIO_CRT].scan_type.realbits = PAC193X_CURRENT_S_RES;
+				ch_sp[IIO_VOLTAVG].scan_type.sign = 's';
+				ch_sp[IIO_VOLTAVG].scan_type.realbits = PAC193X_VOLTAGE_S_RES;
+				ch_sp[IIO_CRTAVG].scan_type.sign = 's';
+				ch_sp[IIO_CRTAVG].scan_type.realbits = PAC193X_CURRENT_S_RES;
 			}
-			/* advance the pointer */
 			tmp_data += sizeof(pac193x_single_channel);
 		}
 	}
-	/* now copy the timestamp channel */
-	memcpy(tmp_data, pac193x_ts, sizeof(pac193x_ts));
-	ch_sp = (struct iio_chan_spec *)tmp_data;
-	ch_sp[0].scan_index = total_iio_chan - 1;
-
-	/* send the updated dynamic channel structure information towards IIO
+	
+	/*
+	 * send the updated dynamic channel structure information towards IIO
 	 * prepare the required field for IIO class registration
 	 */
-	indio_dev->num_channels = total_iio_chan;
-	indio_dev->channels =
-		kmemdup((const struct iio_chan_spec *)dyn_ch_struct,
-				channel_size, GFP_KERNEL);
-	if (!indio_dev->channels) {
-		dev_err(&client->dev, "failed to duplicate channels\n");
+	indio_dev->num_channels = attribute_count;
+	indio_dev->channels = devm_kmemdup(&client->dev,
+									   (const struct iio_chan_spec *)dyn_ch_struct,
+									   channel_size, GFP_KERNEL);
+	
+	kfree(dyn_ch_struct);
+	
+	if (!indio_dev->channels)
 		return -EINVAL;
+	
+	return 0;
+}
+
+static ssize_t reset_accumulators_store(struct device *dev,
+										struct device_attribute *attr,
+										const char *buf, size_t count)
+{
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+	struct pac193x_chip_info *chip_info = iio_priv(indio_dev);
+	int ret, i;
+	u8 refresh_cmd = PAC193X_REFRESH_REG_ADDR;
+	
+	ret = i2c_smbus_write_byte(chip_info->client, refresh_cmd);
+	if (ret) {
+		dev_err(&indio_dev->dev,
+				"%s - cannot send 0x%02X\n",
+		  __func__, refresh_cmd);
 	}
-	/* free the dynamic channels attributes memory */
-	kfree(dyn_ch_struct);
+	
+	for (i = 0 ; i < chip_info->phys_channels; i++)
+		chip_info->chip_reg_data.energy_sec_acc[i] = 0;
+	
+	return count;
+}
 
+static IIO_DEVICE_ATTR(in_shunt_resistor_1, 0644, shunt_value_show, shunt_value_store, 0);
+static IIO_DEVICE_ATTR(in_shunt_resistor_2, 0644, shunt_value_show, shunt_value_store, 0);
+static IIO_DEVICE_ATTR(in_shunt_resistor_3, 0644, shunt_value_show, shunt_value_store, 0);
+static IIO_DEVICE_ATTR(in_shunt_resistor_4, 0644, shunt_value_show, shunt_value_store, 0);
+
+static IIO_DEVICE_ATTR(channel_name_1, 0444, channel_name_show, NULL, 0);
+static IIO_DEVICE_ATTR(channel_name_2, 0444, channel_name_show, NULL, 0);
+static IIO_DEVICE_ATTR(channel_name_3, 0444, channel_name_show, NULL, 0);
+static IIO_DEVICE_ATTR(channel_name_4, 0444, channel_name_show, NULL, 0);
+
+static IIO_DEVICE_ATTR(reset_accumulators, 0200, NULL, reset_accumulators_store, 0);
+
+static struct attribute *pac193x_all_attributes[] = {
+	PAC193X_DEV_ATTR(in_shunt_resistor_1),
+	PAC193X_DEV_ATTR(channel_name_1),
+	PAC193X_DEV_ATTR(in_shunt_resistor_2),
+	PAC193X_DEV_ATTR(channel_name_2),
+	PAC193X_DEV_ATTR(in_shunt_resistor_3),
+	PAC193X_DEV_ATTR(channel_name_3),
+	PAC193X_DEV_ATTR(in_shunt_resistor_4),
+	PAC193X_DEV_ATTR(channel_name_4),
+	PAC193X_DEV_ATTR(reset_accumulators),
+	NULL
+};
+
+static int pac193x_prep_custom_attributes(struct pac193x_chip_info *chip_info,
+										  struct iio_dev *indio_dev)
+{
+	int i, j, active_channels_count = 0;
+	struct attribute **pac193x_custom_attributes;
+	struct attribute_group *pac193x_group;
+	struct i2c_client *client = chip_info->client;
+	
+	for (i = 0 ; i < chip_info->phys_channels; i++)
+		if (chip_info->active_channels[i])
+			active_channels_count++;
+	
+	pac193x_group = devm_kzalloc(&client->dev, sizeof(*pac193x_group), GFP_KERNEL);
+	
+	pac193x_custom_attributes = devm_kzalloc(&client->dev,
+											 (PAC193X_CUSTOM_ATTR_FOR_CHANNEL *
+											 active_channels_count +
+											 PAC193X_SHARED_DEVATTRS_COUNT)
+											 * sizeof(*pac193x_group) + 1,
+											 GFP_KERNEL);
+	j = 0;
+	
+	for (i = 0 ; i < chip_info->phys_channels; i++) {
+		if (chip_info->active_channels[i]) {
+			pac193x_custom_attributes[PAC193X_CUSTOM_ATTR_FOR_CHANNEL * j] =
+			pac193x_all_attributes[PAC193X_CUSTOM_ATTR_FOR_CHANNEL * i];
+			pac193x_custom_attributes[PAC193X_CUSTOM_ATTR_FOR_CHANNEL * j + 1] =
+			pac193x_all_attributes[PAC193X_CUSTOM_ATTR_FOR_CHANNEL * i + 1];
+			j++;
+		}
+	}
+	
+	for (i = 0; i < PAC193X_SHARED_DEVATTRS_COUNT; i++)
+		pac193x_custom_attributes[PAC193X_CUSTOM_ATTR_FOR_CHANNEL *
+		active_channels_count + i] =
+		pac193x_all_attributes[PAC193X_CUSTOM_ATTR_FOR_CHANNEL *
+		chip_info->phys_channels + i];
+	
+	pac193x_group->attrs = pac193x_custom_attributes;
+	chip_info->pac193x_info.attrs = pac193x_group;
+	
 	return 0;
 }
 
-static int pac193x_probe(struct i2c_client *client,
-			  const struct i2c_device_id *id)
+static void pac193x_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(&client->dev);
+	struct pac193x_chip_info *chip_info = iio_priv(indio_dev);
+	
+	cancel_delayed_work_sync(&chip_info->work_chip_rfsh);
+}
+
+static const struct i2c_device_id pac193x_id[] = {
+	{ "pac1931", PAC1931 },
+	{ "pac1932", PAC1932 },
+	{ "pac1933", PAC1933 },
+	{ "pac1934", PAC1934 },
+	{}
+};
+
+static int pac193x_probe(struct i2c_client *client)
 {
 	struct pac193x_chip_info *chip_info;
 	struct iio_dev *indio_dev;
 	const char *name = NULL;
-	int cnt, ret = 0;
-	int dev_id = 0;
-
-	/* allocate the memory for our private structure
-	 * related to the chip info structure
-	 */
+	const struct of_device_id *match;
+	int cnt, ret, dev_id = 0;
+	
 	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip_info));
-	if (!indio_dev)
+	if (!indio_dev) {
+		dev_err_probe(&client->dev, PTR_ERR(indio_dev),
+					  "Can't allocate iio device\n");
 		return -ENOMEM;
-	/* point our chip info structure towards
-	 * the address freshly allocated
-	 */
+	}
+	
 	chip_info = iio_priv(indio_dev);
-	/* make the link between the I2C slave client driver and the IIO */
+	
 	i2c_set_clientdata(client, indio_dev);
 	chip_info->client = client;
-
-	/* get the name and the dev_id */
-	name = id->name;
-	dev_id = id->driver_data;
-	/* store the type of chip */
-	chip_info->chip_variant = dev_id;
-	/* get the maximum number of channels for the given chip id */
-	chip_info->phys_channels = pac193x_chip_config[dev_id].phys_channels;
-	/* clear the chip-related structure */
-	memset(&chip_info->chip_reg_data, 0, sizeof(chip_info->chip_reg_data));
-	/* load default settings - all channels enabled,
-	 * uni directional flow, default shunt values
+	
+	/*
+	 * load default settings - all channels disabled,
+	 * uni directional flow
 	 */
-	for (cnt = 0; cnt < chip_info->phys_channels; cnt++) {
-		chip_info->chip_reg_data.active_channels[cnt] = true;
-		chip_info->chip_reg_data.bi_dir[cnt] = false;
-		chip_info->shunts[cnt] = SHUNT_UOHMS_DEFAULT;
+	for (cnt = 0; cnt < PAC193X_MAX_NUM_CHANNELS; cnt++) {
+		chip_info->active_channels[cnt] = false;
+		chip_info->bi_dir[cnt] = false;
 	}
-	chip_info->chip_reg_data.crt_samp_speed_bitfield = PAC193x_SAMP_1024SPS;
-
-	/* identify the chip we have to deal with */
-	ret = pac193x_chip_identify(chip_info);
-	if (ret < 0)
-		return -EINVAL;
-	/* check if we find the device within DT
-	 * if no settings are available, use the defaults
-	 */
-	if ((!client->dev.of_node) ||
-		(!of_get_next_child(client->dev.of_node, NULL))) {
-		return -EINVAL;
+	
+	chip_info->crt_samp_spd_bitfield = PAC193X_SAMP_1024SPS;
+	
+	if (ACPI_HANDLE(&client->dev)) {
+		pac193x_get_variant(chip_info);
+		
+		switch (chip_info->chip_variant) {
+			case PAC1934_PID:
+				client->dev.init_name = "pac1934";
+				break;
+			case PAC1933_PID:
+				client->dev.init_name = "pac1933";
+				break;
+			case PAC1932_PID:
+				client->dev.init_name = "pac1932";
+				break;
+			case PAC1931_PID:
+				client->dev.init_name = "pac1931";
+				break;
+			default:
+				return -EINVAL;
+		}
+		
+		for (cnt = 0; cnt < PAC193X_MAX_NUM_CHANNELS; cnt++)
+			chip_info->shunts[cnt] = SHUNT_UOHMS_DEFAULT;
+		
+		name = pac193x_match_acpi_device(client, chip_info);
+	} else {
+		dev_id = i2c_match_id(pac193x_id, client)->driver_data;
+		
+		chip_info->chip_variant = dev_id;
+		chip_info->phys_channels = pac193x_chip_config[dev_id].phys_channels;
+		
+		/* identify the chip we have to deal with */
+		ret = pac193x_chip_identify(chip_info);
+		if (ret)
+			return -EINVAL;
+		
+		/* check if we find the device within DT */
+		if (!client->dev.of_node || (!of_get_next_child(client->dev.of_node, NULL)))
+			return -EINVAL;
+		
+		match = of_match_node(pac193x_of_match, client->dev.of_node);
+		if (match) {
+			ret = pac193x_match_of_device(client, chip_info);
+			if (!ret)
+				name = match->compatible;
+		}
 	}
-	/* we have DT */
-	name = pac193x_match_of_device(client, chip_info);
+	
 	if (!name) {
-		dev_err(&client->dev,
-			"DT parameter parsing returned an error\n");
+		dev_err_probe(&client->dev, PTR_ERR(indio_dev),
+					  "parameter parsing returned an error\n");
 		return -EINVAL;
 	}
-
-	/* initialize the chip access mutex */
+	
 	mutex_init(&chip_info->lock);
-	/* do now any chip specific initialization (e.g. read/write
+	
+	/*
+	 * do now any chip specific initialization (e.g. read/write
 	 * some registers), enable/disable certain channels, change the sampling
 	 * rate to the requested value
 	 */
 	ret = pac193x_chip_configure(chip_info);
+	if (ret < 0)
+		goto fail;
+	
 	/* prepare the channel information */
 	ret = pac193x_prep_iio_channels(chip_info, indio_dev);
 	if (ret < 0)
-		goto free_chan_attr_mem;
-	/* configure the IIO related fields and register this device with IIO */
-	indio_dev->info = &pac193x_info;
+		goto fail;
+	
+	ret = pac193x_prep_custom_attributes(chip_info, indio_dev);
+	if (ret < 0) {
+		dev_err_probe(&indio_dev->dev, ret,
+					  "Can't configure custom attributes for PAC193X device\n");
+		goto fail;
+	}
+	
+	chip_info->pac193x_info.read_raw = pac193x_read_raw;
+	chip_info->pac193x_info.read_avail = pac193x_read_avail;
+	chip_info->pac193x_info.write_raw = pac193x_write_raw;
+	
+	indio_dev->info = &chip_info->pac193x_info;
 	indio_dev->name = name;
-	indio_dev->dev.parent = &client->dev;
 	indio_dev->modes = INDIO_DIRECT_MODE;
-	/* read whatever it has been accumulated in the chip so far
+	
+	/*
+	 * read whatever has been accumulated in the chip so far
 	 * and reset the accumulators
 	 */
-	ret = pac193x_reg_snapshot(chip_info, true, false,
-					PAC193x_MIN_UPDATE_WAIT_TIME);
-	/* register with IIO */
+	ret = pac193x_reg_snapshot(chip_info, true, PAC193X_REFRESH_REG_ADDR,
+							   PAC193X_MIN_UPDATE_WAIT_TIME_US);
+	if (ret < 0)
+		goto fail;
+	
 	ret = devm_iio_device_register(&client->dev, indio_dev);
 	if (ret < 0) {
-free_chan_attr_mem:
-		pac193x_remove(client);
-	}
-	return ret;
-}
-
-static int pac193x_remove(struct i2c_client *client)
-{
-	int ret = 0;
-	struct iio_dev *indio_dev = dev_get_drvdata(&client->dev);
-	struct pac193x_chip_info *chip_info = iio_priv(indio_dev);
-	/* free the channel attributes memory */
-	kfree(indio_dev->channels);
-	ret = try_to_del_timer_sync(&chip_info->tmr_forced_update);
-	if (ret < 0) {
-		dev_err(&client->dev,
-		"%s - cannot delete the forced readout timer\n", __func__);
-		return ret;
-	}
-	if (chip_info->wq_chip != NULL) {
-		cancel_work_sync(&chip_info->work_chip_rfsh);
-		flush_workqueue(chip_info->wq_chip);
-		destroy_workqueue(chip_info->wq_chip);
+		dev_err_probe(&indio_dev->dev, ret,
+					  "Can't register IIO device\n");
+		goto fail;
 	}
+	
+	return 0;
+	
+	fail:
+	cancel_delayed_work_sync(&chip_info->work_chip_rfsh);
+	
 	return ret;
 }
 
-static const struct i2c_device_id pac193x_id[] = {
-	{"pac1934", pac1934},
-	{"pac1932", pac1932},
-	{"pac1931", pac1931},
-	{}
-};
 MODULE_DEVICE_TABLE(i2c, pac193x_id);
 
-static const struct of_device_id pac193x_of_match[] = {
-	{ .compatible = "microchip,pac1934",
-		.data = (void *)&pac193x_chip_config[pac1934]},
-	{ .compatible = "microchip,pac1932",
-		.data = (void *)&pac193x_chip_config[pac1932]},
-	{ .compatible = "microchip,pac1931",
-		.data = (void *)&pac193x_chip_config[pac1931]},
-	{ },
-};
 MODULE_DEVICE_TABLE(of, pac193x_of_match);
 
-static const char *pac193x_get_of_match_entry(struct i2c_client *client)
-{
-	const struct of_device_id *match;
-
-	match = of_match_node(pac193x_of_match, client->dev.of_node);
-	return match->compatible;
-}
+static const struct acpi_device_id pac193x_acpi_match[] = {
+	{"MCHP1930", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, pac193x_acpi_match);
 
 static struct i2c_driver pac193x_driver = {
 	.driver	 = {
-			.name = "pac193x",
-			.of_match_table = pac193x_of_match,
-		    },
-	.probe	 = pac193x_probe,
-	.remove		= pac193x_remove,
+		.name = "pac193x",
+		.of_match_table = pac193x_of_match,
+		.acpi_match_table = ACPI_PTR(pac193x_acpi_match)
+	},
+	.probe_new = pac193x_probe,
+	.remove = pac193x_remove,
 	.id_table = pac193x_id,
 };
 
 module_i2c_driver(pac193x_driver);
 
-MODULE_AUTHOR("Bogdan Bolocan");
-MODULE_DESCRIPTION("PAC193x");
-MODULE_LICENSE("GPL v2");
-MODULE_VERSION("0.0.1");
+MODULE_AUTHOR("Bogdan Bolocan <bogdan.bolocan@microchip.com>");
+MODULE_AUTHOR("Victor Tudose");
+MODULE_AUTHOR("Marius Cristea <marius.cristea@microchip.com>");
+MODULE_DESCRIPTION("IIO driver for PAC193X Multi-Channel DC Power/Energy Monitor");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.2.1");
