From 656ae4cf1e01da0f01d986a4b76138c70590cc55 Mon Sep 17 00:00:00 2001
From: tflynn <tflynn@redwiretechnologies.us>
Date: Tue, 16 Aug 2022 13:38:54 -0400
Subject: [PATCH] support for 808 and WT accessary card

---
 .../src/rwt_DS80PCI102-Registers.h            |   35 +
 lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102.c  |   44 +
 lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102.h  |   26 +
 .../src/rwt_DS80PCI800-Registers.h            |   61 +
 lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800.c  |   44 +
 lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800.h  |   26 +
 .../zynqmp_fsbl/src/te_Si5345-Registers.h     |  994 ++++++++++++++
 ...define_te0803.h => te_iic_define_te0808.h} |  151 ++-
 .../zynqmp_fsbl/src/te_iic_define_te0820.h    |   69 -
 lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.c | 1149 +++++++++--------
 lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.h |  134 +-
 lib/sw_apps/zynqmp_fsbl/src/te_si534x.c       |  232 ++++
 lib/sw_apps/zynqmp_fsbl/src/te_si534x.h       |   43 +
 lib/sw_apps/zynqmp_fsbl/src/te_uart.c         |   94 +-
 lib/sw_apps/zynqmp_fsbl/src/te_uart.h         |   80 +-
 lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks.h  |    2 +-
 ...hooks_te0803.c => te_xfsbl_hooks_te0808.c} |  145 ++-
 ...hooks_te0803.h => te_xfsbl_hooks_te0808.h} |   13 +-
 18 files changed, 2474 insertions(+), 868 deletions(-)
 create mode 100644 lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102-Registers.h
 create mode 100644 lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102.c
 create mode 100644 lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102.h
 create mode 100644 lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800-Registers.h
 create mode 100644 lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800.c
 create mode 100644 lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800.h
 create mode 100644 lib/sw_apps/zynqmp_fsbl/src/te_Si5345-Registers.h
 rename lib/sw_apps/zynqmp_fsbl/src/{te_iic_define_te0803.h => te_iic_define_te0808.h} (79%)
 delete mode 100644 lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0820.h
 create mode 100644 lib/sw_apps/zynqmp_fsbl/src/te_si534x.c
 create mode 100644 lib/sw_apps/zynqmp_fsbl/src/te_si534x.h
 rename lib/sw_apps/zynqmp_fsbl/src/{te_xfsbl_hooks_te0803.c => te_xfsbl_hooks_te0808.c} (79%)
 rename lib/sw_apps/zynqmp_fsbl/src/{te_xfsbl_hooks_te0803.h => te_xfsbl_hooks_te0808.h} (88%)

diff --git a/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102-Registers.h b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102-Registers.h
new file mode 100644
index 0000000000..81cf421b98
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102-Registers.h
@@ -0,0 +1,35 @@
+/*
+ * DS80PCI102 Configuration Register Header File
+ *
+ */
+
+#ifndef DS80PCI102_REG_CONFIG_HEADER
+#define DS80PCI102_REG_CONFIG_HEADER
+
+#define DS80PCI102_REG_CONFIG_NUM_REGS				9
+
+typedef struct
+{
+	unsigned char address; /* 16-bit register address */
+	unsigned char value; /* 8-bit register data */
+
+} ds80pci102_register_t;
+
+ds80pci102_register_t const ds80pci102_registers[DS80PCI102_REG_CONFIG_NUM_REGS] =
+{
+
+	{ 0x06, 0x18 },
+	{ 0x08, 0x40 },
+	{ 0x0E, 0x0C },
+	{ 0x0F, 0x00 },
+	{ 0x25, 0xAD },
+	{ 0x11, 0x00 },
+    { 0x16, 0x00 },
+    { 0x2D, 0xAD },
+    { 0x18, 0x00 },
+    
+};
+
+
+
+#endif
diff --git a/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102.c b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102.c
new file mode 100644
index 0000000000..ad1d7163d3
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102.c
@@ -0,0 +1,44 @@
+/*
+-- Company: 		Red Wire Technologies
+-- Engineer: 		Toby Flynn
+ */
+#include "rwt_DS80PCI102.h"
+
+#ifdef PCI_DS80PCI102
+
+#include "te_uart.h"
+#include "rwt_DS80PCI102-Registers.h"
+
+
+
+int DS80PCI102_init(unsigned char chip_addr){
+    int i, Status;
+    unsigned char val;
+    unsigned char addr;
+    
+   
+    p_printf(("PCI Redriver Registers Write.\r\n"));
+
+  
+    #ifdef DS80PCI102_REG_CONFIG_NUM_REGS
+
+    for (i=0; i<DS80PCI102_REG_CONFIG_NUM_REGS; ++i) {
+        val = ds80pci102_registers[i].value;
+        addr = ds80pci102_registers[i].address;
+      Status = iic_write8(chip_addr, addr, val);
+      if(Status != XST_SUCCESS) {
+          p_printf(("Couldn't write value 0x%02X to address 0x%04X.\n", val, addr));
+          p_printf(("There were %d succesful I2C writes so far.\n", i));
+          return Status;
+      }
+    
+    }
+    #endif
+
+	
+	p_printf(("DS80PCI102 Init Complete.\r\n"));
+
+	return XST_SUCCESS;
+}
+
+#endif /*PCI_DS80PCI102*/
diff --git a/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102.h b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102.h
new file mode 100644
index 0000000000..199678d6a0
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI102.h
@@ -0,0 +1,26 @@
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+#ifndef DS80PCI102_H
+#define DS80PCI102_H
+
+#include "te_iic_platform.h"
+#ifdef PCI_DS80PCI102
+
+
+#define DS80PCI102_CHIP_ADDR	0x59
+
+
+
+
+//enable register read back and printf
+//#define DEBUG_REG	
+
+
+int DS80PCI102_init(unsigned char chip_addr);
+
+
+#endif /* PCI_DS80PCI102 */
+
+#endif /* DS80PCI102_H */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800-Registers.h b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800-Registers.h
new file mode 100644
index 0000000000..39067ec28c
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800-Registers.h
@@ -0,0 +1,61 @@
+/*
+ * DS80PCI800 Configuration Register Header File
+ *
+ */
+
+#ifndef DS80PCI800_REG_CONFIG_HEADER
+#define DS80PCI800_REG_CONFIG_HEADER
+
+#define DS80PCI800_REG_CONFIG_NUM_REGS				34
+
+typedef struct
+{
+	unsigned char address; /* 16-bit register address */
+	unsigned char value; /* 8-bit register data */
+
+} ds80pci800_register_t;
+
+ds80pci800_register_t const ds80pci800_registers[DS80PCI800_REG_CONFIG_NUM_REGS] =
+{
+
+	
+	{ 0x06, 0x18 },
+	{ 0x08, 0x4C },
+	{ 0x0E, 0x0C },
+	{ 0x0F, 0x00 },
+	{ 0x10, 0xAD },
+	{ 0x11, 0x00 },
+	{ 0x15, 0x0C },
+    { 0x16, 0x00 },
+    { 0x17, 0xAD },
+    { 0x18, 0x00 },
+    { 0x1C, 0x0C },
+    { 0x1D, 0x00 },
+    { 0x1E, 0xAD },
+    { 0x1F, 0x00 },
+    { 0x23, 0x0C },
+    { 0x24, 0x00 },
+    { 0x25, 0xAD },
+    { 0x26, 0x00 },
+    { 0x2B, 0x0C },
+    { 0x2C, 0x00 },
+    { 0x2D, 0xAD },
+    { 0x2E, 0x00 },
+    { 0x32, 0x0C },
+    { 0x33, 0x00 },
+    { 0x34, 0xAD },
+    { 0x35, 0x00 },
+    { 0x39, 0x0C },
+    { 0x3A, 0x00 },
+    { 0x3B, 0xAD },
+    { 0x3C, 0x00 },
+    { 0x40, 0x0C },
+    { 0x41, 0x00 },
+    { 0x42, 0xAD },
+    { 0x42, 0x00 },
+	
+};
+
+
+
+#endif
diff --git a/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800.c b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800.c
new file mode 100644
index 0000000000..45026cbc6c
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800.c
@@ -0,0 +1,44 @@
+/*
+-- Company: 		Red Wire Technologies
+-- Engineer: 		Toby Flynn
+ */
+#include "rwt_DS80PCI800.h"
+
+#ifdef PCI_DS80PCI800
+
+#include "te_uart.h"
+#include "rwt_DS80PCI800-Registers.h"
+
+
+
+int DS80PCI800_init(unsigned char chip_addr){
+    int i, Status;
+    unsigned char val;
+    unsigned char addr;
+    
+
+    p_printf(("PCI Redriver Registers Write.\r\n"));
+
+  
+    #ifdef DS80PCI800_REG_CONFIG_NUM_REGS
+
+    for (i=0; i<DS80PCI800_REG_CONFIG_NUM_REGS; ++i) {
+        val = ds80pci800_registers[i].value;
+        addr = ds80pci800_registers[i].address;
+      Status = iic1_write8(chip_addr, addr, val);
+      if(Status != XST_SUCCESS) {
+          p_printf(("Couldn't write value 0x%02X to address 0x%04X.\n", val, addr));
+          p_printf(("There were %d succesful I2C writes so far.\n", i));
+          return Status;
+      }
+    
+    }
+    #endif
+
+	
+	p_printf(("DS80PCI800 Init Complete.\r\n"));
+
+	return XST_SUCCESS;
+}
+
+#endif /*PCI_DS80PCI800*/
diff --git a/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800.h b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800.h
new file mode 100644
index 0000000000..fbbd2a8a27
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/rwt_DS80PCI800.h
@@ -0,0 +1,26 @@
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+#ifndef DS80PCI800_H
+#define DS80PCI800_H
+
+#include "te_iic_platform.h"
+#ifdef PCI_DS80PCI800
+
+
+#define DS80PCI800_CHIP_ADDR	0x58
+
+
+
+
+//enable register read back and printf
+//#define DEBUG_REG	
+
+
+int DS80PCI800_init(unsigned char chip_addr);
+
+
+#endif /* PCI_DS80PCI800 */
+
+#endif /* DS80PCI800_H */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_Si5345-Registers.h b/lib/sw_apps/zynqmp_fsbl/src/te_Si5345-Registers.h
new file mode 100644
index 0000000000..5f5b7d5aa6
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_Si5345-Registers.h
@@ -0,0 +1,994 @@
+/*
+ * Si5345 Rev B Configuration Register Export Header File
+ *
+ * This file represents a series of Silicon Labs Si5345 Rev B 
+ * register writes that can be performed to load a single configuration 
+ * on a device. It was created by a Silicon Labs ClockBuilder Pro
+ * export tool.
+ *
+ * Part:		                                       Si5345 Rev B
+ * Design ID:                                          808-B
+ * Includes Pre/Post Download Control Register Writes: Yes
+ * Created By:                                         ClockBuilder Pro v2.43 [2020-03-31]
+ * Timestamp:                                          2020-06-03 08:01:33 GMT+02:00
+ *
+ * A complete design report corresponding to this export is included at the end 
+ * of this header file.
+ *
+ */
+
+#ifndef SI5345_REVB_REG_CONFIG_HEADER
+#define SI5345_REVB_REG_CONFIG_HEADER
+
+#define SI5345_REVB_REG_CONFIG_NUM_REGS				386
+
+typedef struct
+{
+	unsigned int address; /* 16-bit register address */
+	unsigned char value; /* 8-bit register data */
+
+} si5345_revb_register_t;
+
+si5345_revb_register_t const si5345_revb_registers[SI5345_REVB_REG_CONFIG_NUM_REGS] =
+{
+
+	/* Start configuration preamble */
+	{ 0x0B24, 0xD8 },
+	{ 0x0B25, 0x00 },
+	{ 0x0540, 0x01 },
+	/* End configuration preamble */
+
+	/* Delay 300 msec */
+	/*    Delay is worst case time for device to complete any calibration */
+	/*    that is running due to device state change previous to this script */
+	/*    being processed. */
+
+	/* Start configuration registers */
+	{ 0x000B, 0x68 },
+	{ 0x0016, 0x02 },
+	{ 0x0017, 0x1C },
+	{ 0x0018, 0xEE },
+	{ 0x0019, 0xDD },
+	{ 0x001A, 0xDF },
+	{ 0x002B, 0x02 },
+	{ 0x002C, 0x01 },
+	{ 0x002D, 0x01 },
+	{ 0x002E, 0x3B },
+	{ 0x002F, 0x00 },
+	{ 0x0030, 0x00 },
+	{ 0x0031, 0x00 },
+	{ 0x0032, 0x00 },
+	{ 0x0033, 0x00 },
+	{ 0x0034, 0x00 },
+	{ 0x0035, 0x00 },
+	{ 0x0036, 0x3B },
+	{ 0x0037, 0x00 },
+	{ 0x0038, 0x00 },
+	{ 0x0039, 0x00 },
+	{ 0x003A, 0x00 },
+	{ 0x003B, 0x00 },
+	{ 0x003C, 0x00 },
+	{ 0x003D, 0x00 },
+	{ 0x003F, 0x11 },
+	{ 0x0040, 0x04 },
+	{ 0x0041, 0x0B },
+	{ 0x0042, 0x00 },
+	{ 0x0043, 0x00 },
+	{ 0x0044, 0x00 },
+	{ 0x0045, 0x0C },
+	{ 0x0046, 0x64 },
+	{ 0x0047, 0x00 },
+	{ 0x0048, 0x00 },
+	{ 0x0049, 0x00 },
+	{ 0x004A, 0x64 },
+	{ 0x004B, 0x00 },
+	{ 0x004C, 0x00 },
+	{ 0x004D, 0x00 },
+	{ 0x004E, 0x05 },
+	{ 0x004F, 0x00 },
+	{ 0x0050, 0x0F },
+	{ 0x0051, 0x03 },
+	{ 0x0052, 0x00 },
+	{ 0x0053, 0x00 },
+	{ 0x0054, 0x00 },
+	{ 0x0055, 0x03 },
+	{ 0x0056, 0x00 },
+	{ 0x0057, 0x00 },
+	{ 0x0058, 0x00 },
+	{ 0x0059, 0x03 },
+	{ 0x005A, 0x00 },
+	{ 0x005B, 0x00 },
+	{ 0x005C, 0x00 },
+	{ 0x005D, 0x01 },
+	{ 0x005E, 0x00 },
+	{ 0x005F, 0x00 },
+	{ 0x0060, 0x00 },
+	{ 0x0061, 0x00 },
+	{ 0x0062, 0x00 },
+	{ 0x0063, 0x00 },
+	{ 0x0064, 0x00 },
+	{ 0x0065, 0x00 },
+	{ 0x0066, 0x00 },
+	{ 0x0067, 0x00 },
+	{ 0x0068, 0x00 },
+	{ 0x0069, 0x00 },
+	{ 0x0092, 0x00 },
+	{ 0x0093, 0x00 },
+	{ 0x0095, 0x00 },
+	{ 0x0096, 0x00 },
+	{ 0x0098, 0x00 },
+	{ 0x009A, 0x02 },
+	{ 0x009B, 0x30 },
+	{ 0x009D, 0x00 },
+	{ 0x009E, 0x20 },
+	{ 0x00A0, 0x00 },
+	{ 0x00A2, 0x02 },
+	{ 0x00A8, 0x43 },
+	{ 0x00A9, 0x88 },
+	{ 0x00AA, 0x08 },
+	{ 0x00AB, 0x00 },
+	{ 0x00AC, 0x00 },
+	{ 0x0102, 0x01 },
+	{ 0x0108, 0x02 },
+	{ 0x0109, 0x09 },
+	{ 0x010A, 0x3D },
+	{ 0x010B, 0x00 },
+	{ 0x010D, 0x02 },
+	{ 0x010E, 0x09 },
+	{ 0x010F, 0x3D },
+	{ 0x0110, 0x00 },
+	{ 0x0112, 0x02 },
+	{ 0x0113, 0x09 },
+	{ 0x0114, 0x3D },
+	{ 0x0115, 0x00 },
+	{ 0x0117, 0x01 },
+	{ 0x0118, 0x09 },
+	{ 0x0119, 0x3B },
+	{ 0x011A, 0x00 },
+	{ 0x011C, 0x02 },
+	{ 0x011D, 0x09 },
+	{ 0x011E, 0x3D },
+	{ 0x011F, 0x00 },
+	{ 0x0121, 0x02 },
+	{ 0x0122, 0x09 },
+	{ 0x0123, 0x3D },
+	{ 0x0124, 0x02 },
+	{ 0x0126, 0x02 },
+	{ 0x0127, 0x09 },
+	{ 0x0128, 0x3D },
+	{ 0x0129, 0x03 },
+	{ 0x012B, 0x06 },
+	{ 0x012C, 0x09 },
+	{ 0x012D, 0x3D },
+	{ 0x012E, 0x01 },
+	{ 0x0130, 0x02 },
+	{ 0x0131, 0x09 },
+	{ 0x0132, 0x3D },
+	{ 0x0133, 0x00 },
+	{ 0x013A, 0x01 },
+	{ 0x013B, 0x09 },
+	{ 0x013C, 0x3B },
+	{ 0x013D, 0x00 },
+	{ 0x013F, 0x00 },
+	{ 0x0140, 0x00 },
+	{ 0x0141, 0x40 },
+	{ 0x0142, 0xFF },
+	{ 0x0202, 0x00 },
+	{ 0x0203, 0x00 },
+	{ 0x0204, 0x00 },
+	{ 0x0205, 0x00 },
+	{ 0x0206, 0x00 },
+	{ 0x0208, 0x0D },
+	{ 0x0209, 0x00 },
+	{ 0x020A, 0x00 },
+	{ 0x020B, 0x00 },
+	{ 0x020C, 0x00 },
+	{ 0x020D, 0x00 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x00 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x00 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x00 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x0218, 0x00 },
+	{ 0x0219, 0x00 },
+	{ 0x021A, 0x00 },
+	{ 0x021B, 0x00 },
+	{ 0x021C, 0x00 },
+	{ 0x021D, 0x00 },
+	{ 0x021E, 0x00 },
+	{ 0x021F, 0x00 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x00 },
+	{ 0x0222, 0x00 },
+	{ 0x0223, 0x00 },
+	{ 0x0224, 0x00 },
+	{ 0x0225, 0x00 },
+	{ 0x0226, 0x00 },
+	{ 0x0227, 0x00 },
+	{ 0x0228, 0x00 },
+	{ 0x0229, 0x00 },
+	{ 0x022A, 0x00 },
+	{ 0x022B, 0x00 },
+	{ 0x022C, 0x00 },
+	{ 0x022D, 0x00 },
+	{ 0x022E, 0x00 },
+	{ 0x022F, 0x00 },
+	{ 0x0231, 0x01 },
+	{ 0x0232, 0x01 },
+	{ 0x0233, 0x01 },
+	{ 0x0234, 0x01 },
+	{ 0x0235, 0x00 },
+	{ 0x0236, 0x00 },
+	{ 0x0237, 0x00 },
+	{ 0x0238, 0x00 },
+	{ 0x0239, 0x8C },
+	{ 0x023A, 0x00 },
+	{ 0x023B, 0x00 },
+	{ 0x023C, 0x00 },
+	{ 0x023D, 0x00 },
+	{ 0x023E, 0x80 },
+	{ 0x024A, 0x04 },
+	{ 0x024B, 0x00 },
+	{ 0x024C, 0x00 },
+	{ 0x024D, 0x03 },
+	{ 0x024E, 0x00 },
+	{ 0x024F, 0x00 },
+	{ 0x0250, 0x04 },
+	{ 0x0251, 0x00 },
+	{ 0x0252, 0x00 },
+	{ 0x0253, 0x00 },
+	{ 0x0254, 0x00 },
+	{ 0x0255, 0x00 },
+	{ 0x0256, 0x04 },
+	{ 0x0257, 0x00 },
+	{ 0x0258, 0x00 },
+	{ 0x0259, 0x02 },
+	{ 0x025A, 0x00 },
+	{ 0x025B, 0x00 },
+	{ 0x025C, 0x01 },
+	{ 0x025D, 0x00 },
+	{ 0x025E, 0x00 },
+	{ 0x025F, 0x00 },
+	{ 0x0260, 0x00 },
+	{ 0x0261, 0x00 },
+	{ 0x0262, 0x13 },
+	{ 0x0263, 0x00 },
+	{ 0x0264, 0x00 },
+	{ 0x0268, 0x00 },
+	{ 0x0269, 0x00 },
+	{ 0x026A, 0x00 },
+	{ 0x026B, 0x38 },
+	{ 0x026C, 0x30 },
+	{ 0x026D, 0x38 },
+	{ 0x026E, 0x2D },
+	{ 0x026F, 0x42 },
+	{ 0x0270, 0x20 },
+	{ 0x0271, 0x20 },
+	{ 0x0272, 0x20 },
+	{ 0x0302, 0x00 },
+	{ 0x0303, 0x00 },
+	{ 0x0304, 0x00 },
+	{ 0x0305, 0x00 },
+	{ 0x0306, 0x07 },
+	{ 0x0307, 0x00 },
+	{ 0x0308, 0x00 },
+	{ 0x0309, 0x00 },
+	{ 0x030A, 0x00 },
+	{ 0x030B, 0x80 },
+	{ 0x030C, 0x00 },
+	{ 0x030D, 0x00 },
+	{ 0x030E, 0x00 },
+	{ 0x030F, 0x00 },
+	{ 0x0310, 0x00 },
+	{ 0x0311, 0x1C },
+	{ 0x0312, 0x00 },
+	{ 0x0313, 0x00 },
+	{ 0x0314, 0x00 },
+	{ 0x0315, 0x00 },
+	{ 0x0316, 0xA0 },
+	{ 0x0317, 0x00 },
+	{ 0x0318, 0x00 },
+	{ 0x0319, 0x00 },
+	{ 0x031A, 0x00 },
+	{ 0x031B, 0xB0 },
+	{ 0x031C, 0x36 },
+	{ 0x031D, 0x00 },
+	{ 0x031E, 0x00 },
+	{ 0x031F, 0x00 },
+	{ 0x0320, 0x00 },
+	{ 0x0321, 0xA2 },
+	{ 0x0322, 0x00 },
+	{ 0x0323, 0x00 },
+	{ 0x0324, 0x00 },
+	{ 0x0325, 0x00 },
+	{ 0x0326, 0x2E },
+	{ 0x0327, 0x22 },
+	{ 0x0328, 0x00 },
+	{ 0x0329, 0x00 },
+	{ 0x032A, 0x00 },
+	{ 0x032B, 0x00 },
+	{ 0x032C, 0xC5 },
+	{ 0x032D, 0x00 },
+	{ 0x032E, 0x00 },
+	{ 0x032F, 0x00 },
+	{ 0x0330, 0x00 },
+	{ 0x0331, 0x00 },
+	{ 0x0332, 0x00 },
+	{ 0x0333, 0x00 },
+	{ 0x0334, 0x00 },
+	{ 0x0335, 0x00 },
+	{ 0x0336, 0x00 },
+	{ 0x0337, 0x00 },
+	{ 0x0338, 0x00 },
+	{ 0x0339, 0x1F },
+	{ 0x033B, 0x00 },
+	{ 0x033C, 0x00 },
+	{ 0x033D, 0x00 },
+	{ 0x033E, 0x00 },
+	{ 0x033F, 0x00 },
+	{ 0x0340, 0x00 },
+	{ 0x0341, 0x00 },
+	{ 0x0342, 0x00 },
+	{ 0x0343, 0x00 },
+	{ 0x0344, 0x00 },
+	{ 0x0345, 0x00 },
+	{ 0x0346, 0x00 },
+	{ 0x0347, 0x00 },
+	{ 0x0348, 0x00 },
+	{ 0x0349, 0x00 },
+	{ 0x034A, 0x00 },
+	{ 0x034B, 0x00 },
+	{ 0x034C, 0x00 },
+	{ 0x034D, 0x00 },
+	{ 0x034E, 0x00 },
+	{ 0x034F, 0x00 },
+	{ 0x0350, 0x00 },
+	{ 0x0351, 0x00 },
+	{ 0x0352, 0x00 },
+	{ 0x0353, 0x00 },
+	{ 0x0354, 0x00 },
+	{ 0x0355, 0x00 },
+	{ 0x0356, 0x00 },
+	{ 0x0357, 0x00 },
+	{ 0x0358, 0x00 },
+	{ 0x0359, 0x00 },
+	{ 0x035A, 0x00 },
+	{ 0x035B, 0x00 },
+	{ 0x035C, 0x00 },
+	{ 0x035D, 0x00 },
+	{ 0x035E, 0x00 },
+	{ 0x035F, 0x00 },
+	{ 0x0360, 0x00 },
+	{ 0x0361, 0x00 },
+	{ 0x0362, 0x00 },
+	{ 0x0487, 0x00 },
+	{ 0x0508, 0x13 },
+	{ 0x0509, 0x22 },
+	{ 0x050A, 0x0C },
+	{ 0x050B, 0x0B },
+	{ 0x050C, 0x07 },
+	{ 0x050D, 0x3F },
+	{ 0x050E, 0x16 },
+	{ 0x050F, 0x2A },
+	{ 0x0510, 0x09 },
+	{ 0x0511, 0x08 },
+	{ 0x0512, 0x07 },
+	{ 0x0513, 0x3F },
+	{ 0x0515, 0x00 },
+	{ 0x0516, 0x00 },
+	{ 0x0517, 0x00 },
+	{ 0x0518, 0x00 },
+	{ 0x0519, 0xD8 },
+	{ 0x051A, 0x02 },
+	{ 0x051B, 0x00 },
+	{ 0x051C, 0x00 },
+	{ 0x051D, 0x00 },
+	{ 0x051E, 0x00 },
+	{ 0x051F, 0x80 },
+	{ 0x0521, 0x21 },
+	{ 0x052A, 0x01 },
+	{ 0x052B, 0x01 },
+	{ 0x052C, 0x0F },
+	{ 0x052D, 0x03 },
+	{ 0x052E, 0x19 },
+	{ 0x052F, 0x19 },
+	{ 0x0531, 0x00 },
+	{ 0x0532, 0x63 },
+	{ 0x0533, 0x03 },
+	{ 0x0534, 0x00 },
+	{ 0x0535, 0x00 },
+	{ 0x0536, 0x0C },
+	{ 0x0537, 0x00 },
+	{ 0x0538, 0x00 },
+	{ 0x0539, 0x00 },
+	{ 0x0802, 0x35 },
+	{ 0x0803, 0x05 },
+	{ 0x0804, 0x00 },
+	{ 0x090E, 0x02 },
+	{ 0x0943, 0x00 },
+	{ 0x0949, 0x01 },
+	{ 0x094A, 0x01 },
+	{ 0x0A02, 0x00 },
+	{ 0x0A03, 0x0F },
+	{ 0x0A04, 0x01 },
+	{ 0x0A05, 0x0F },
+	{ 0x0B44, 0x2F },
+	{ 0x0B46, 0x00 },
+	{ 0x0B47, 0x0E },
+	{ 0x0B48, 0x0E },
+	{ 0x0B4A, 0x10 },
+	/* End configuration registers */
+
+	/* Start configuration postamble */
+	{ 0x0514, 0x01 },
+	{ 0x001C, 0x01 },
+	{ 0x0540, 0x00 },
+	{ 0x0B24, 0xDB },
+	{ 0x0B25, 0x02 },
+	/* End configuration postamble */
+
+};
+
+/*
+ * Design Report
+ *
+ * Overview
+ * ========
+ * Part:               Si5345AB Rev B
+ * Project File:       B:\Design\cores\xilinx\2019.2\design\TE0808\StarterKit\misc\SI5345\Si5345-RevB-808-B-Project.slabtimeproj
+ * Design ID:          808-B
+ * Created By:         ClockBuilder Pro v2.43 [2020-03-31]
+ * Timestamp:          2020-06-03 08:01:33 GMT+02:00
+ * 
+ * Design Rule Check
+ * =================
+ * Errors:
+ * - No errors
+ * 
+ * Warnings:
+ * - OUT5 [27 MHz] and OUT4 [100 MHz] may have coupling [1]
+ * - OUT5 [27 MHz] and OUT6 [78.8 MHz] may have coupling [1]
+ * - OUT6 [78.8 MHz] and OUT7 [156.25 MHz] may have coupling [1]
+ * - Revision B is not recommended for new designs
+ * 
+ * Footnotes:
+ * [1] To avoid coupling in outputs, Silicon Labs recommends the following:
+ * 
+ * - Avoid adjacent frequency values that are close. CBPro uses an output's integration bandwidth (IBW) to determine whether two adjacent frequencies are too close. An IBW of 20 MHz is used for frequencies 80 MHz and larger. Lower frequencies will use IBW of OUT/4. CBPro will flag fundamental coupling and coupling up to the fourth harmonic, where coupling frequency = Absolute(OUTa*x - OUTb*y) for all combinations of x and y 1 through 4. If any one of these values is less than or equal to the IBW, the output is flagged as having possible coupling.
+ * - Adjacent frequency values that are integer multiples of one another are okay and these outputs should be grouped accordingly. For example, a 155.52 MHz and 622.08 MHz (155.52 x 4) can be adjacent.
+ * - Unused outputs can be used to separate clock outputs that might otherwise interfere with one another.
+ * 
+ * Silicon Labs recommends you validate your design's jitter performance using an Evaluation Board. You can request a custom phase noise report for your design from CBPro's design dashboard.
+ * 
+ * Device Grade
+ * ============
+ * Maximum Output Frequency: 156.25 MHz
+ * Frequency Synthesis Mode: Fractional
+ * Frequency Plan Grade:     B
+ * Minimum Base OPN:         Si5345B*
+ * 
+ * Base       Output Clock         Supported Frequency Synthesis Modes
+ * OPN Grade  Frequency Range      (Typical Jitter)
+ * ---------  -------------------  --------------------------------------------
+ * Si5345A    100 Hz to 712.5 MHz  Integer (< 100 fs) and fractional (< 150 fs)
+ * Si5345B*   100 Hz to 350 MHz    "
+ * Si5345C    100 Hz to 712.5 MHz  Integer only (< 100 fs)
+ * Si5345D    100 Hz to 350 MHz    "
+ * 
+ * * Based on your calculated frequency plan, a Si5345B grade device is
+ * sufficient for your design. For more in-system configuration flexibility
+ * (higher frequencies and/or to enable fractional synthesis), consider
+ * selecting device grade Si5345A when specifying an ordering part number (OPN)
+ * for your application. See the datasheet Ordering Guide for more information.
+ * 
+ * Design
+ * ======
+ * Host Interface:
+ *    I/O Power Supply: VDD (Core)
+ *    SPI Mode: 4-Wire
+ *    I2C Address Range: 104d to 107d / 0x68 to 0x6B (selected via A0/A1 pins)
+ * 
+ * XA/XB:
+ *    50 MHz (XTAL - Crystal)
+ * 
+ * Inputs:
+ *     IN0: 25 MHz
+ *          Standard
+ *     IN1: Unused
+ *     IN2: Unused
+ *     IN3: Unused
+ * 
+ * Outputs:
+ *    OUT0: 100 MHz
+ *          Enabled, LVDS 1.8 V
+ *    OUT1: 125 MHz
+ *          Enabled, LVDS 1.8 V
+ *    OUT2: 100 MHz
+ *          Enabled, LVDS 1.8 V
+ *    OUT3: Unused
+ *    OUT4: 100 MHz
+ *          Enabled, LVDS 1.8 V
+ *    OUT5: 27 MHz
+ *          Enabled, LVDS 1.8 V
+ *    OUT6: 78.8 MHz
+ *          Enabled, LVDS 1.8 V
+ *    OUT7: 156.25 MHz
+ *          Enabled, LVDS 1.8 V
+ *    OUT8: 25 MHz
+ *          Enabled, LVDS 1.8 V
+ *    OUT9: Unused
+ * 
+ * Frequency Plan
+ * ==============
+ * Priority: maximize the number of low jitter outputs
+ * 
+ * Fvco = 14 GHz
+ * Fpfd = 1.9230769230769230... MHz [ 1 + 12/13 MHz ]
+ * Fms0 = 1 GHz
+ * Fms1 = 312.5 MHz
+ * Fms2 = 162 MHz
+ * Fms3 = 315.2 MHz
+ * 
+ * P dividers:
+ *    P0  = 13
+ *    P1  = Unused
+ *    P2  = Unused
+ *    P3  = Unused
+ *    Pxaxb = 1
+ * 
+ * MXAXB = 280
+ * M = 1456
+ * N dividers:
+ *    N0:
+ *       Value: 14
+ *       OUT0: 100 MHz
+ *       OUT1: 125 MHz
+ *       OUT2: 100 MHz
+ *       OUT4: 100 MHz
+ *       OUT8: 25 MHz
+ *    N1:
+ *       Value: 44.8
+ *       OUT7: 156.25 MHz [ 156 + 1/4 MHz ]
+ *    N2:
+ *       Value: 86.4197530864197530... [ 86 + 34/81 ]
+ *       OUT5: 27 MHz
+ *    N3:
+ *       Value: 44.4162436548223350... [ 44 + 82/197 ]
+ *       OUT6: 78.8 MHz [ 78 + 4/5 MHz ]
+ *    N4:
+ *       Unused
+ * 
+ * R dividers:
+ *    R0 = 10
+ *    R1 = 8
+ *    R2 = 10
+ *    R3 = Unused
+ *    R4 = 10
+ *    R5 = 6
+ *    R6 = 4
+ *    R7 = 2
+ *    R8 = 40
+ *    R9 = Unused
+ * 
+ * Nominal Bandwidth:
+ *   Desired: 100.000 Hz
+ *   Actual:  84.493 Hz
+ *   Coefficients:
+ *      BW0:  19
+ *      BW1:  34
+ *      BW2:  12
+ *      BW3:  11
+ *      BW4:  7
+ *      BW5:  63
+ * Fastlock Bandwidth:
+ *   Desired: 1.000 kHz
+ *   Actual:  676.620 Hz
+ *   Coefficients:
+ *      BW0:  22
+ *      BW1:  42
+ *      BW2:  9
+ *      BW3:  8
+ *      BW4:  7
+ *      BW5:  63
+ * 
+ * Dividers listed above show effective values. These values are translated to register settings by ClockBuilder Pro. For the actual register values, see below. Refer to the Family Reference Manual for information on registers related to frequency plan.
+ * 
+ * Digitally Controlled Oscillator (DCO)
+ * =====================================
+ * Mode: Register Direct Write
+ * 
+ * N0: DCO Disabled
+ * 
+ * N1: DCO Disabled
+ * 
+ * N2: DCO Disabled
+ * 
+ * N3: DCO Disabled
+ * 
+ * N4: DCO Disabled
+ * 
+ * Revision B Frequency Offset Errata Report
+ * =========================================
+ * 
+ * Output  Frequency   Offset(Max,ppt)
+ * ------  ----------  ---------------
+ * OUT0    100 MHz     0.000000       
+ * OUT1    125 MHz     0.000000       
+ * OUT2    100 MHz     0.000000       
+ * OUT3    Unused                     
+ * OUT4    100 MHz     0.000000       
+ * OUT5    27 MHz      0.000000       
+ * OUT6    78.8 MHz    0.000000       
+ * OUT7    156.25 MHz  0.000000       
+ * OUT8    25 MHz      0.000000       
+ * OUT9    Unused                     
+ * 
+ * Offset is reported in parts-per-trillion (1e12).
+ * 
+ * Estimated Power & Junction Temperature
+ * ======================================
+ * Assumptions:
+ * 
+ * Revision: B
+ * VDD:      1.8 V
+ * Ta:       25 °C
+ * Theta-JA: 18.3 °C/W
+ * Airflow:  2 m/s
+ * 
+ * Total Power: 929 mW, On Chip Power: 881 mW, Tj: 41 °C
+ * 
+ *          Frequency  Format   Voltage   Current     Power
+ *         ----------  ------  --------  --------  --------
+ * VDD                            1.8 V  173.7 mA    313 mW
+ * VDDA                           3.3 V  119.5 mA    394 mW
+ * VDDO0      100 MHz  LVDS       1.8 V   15.5 mA     28 mW
+ * VDDO1      125 MHz  LVDS       1.8 V   15.6 mA     28 mW
+ * VDDO2      100 MHz  LVDS       1.8 V   15.5 mA     28 mW
+ * VDDO3       Unused                                      
+ * VDDO4      100 MHz  LVDS       1.8 V   15.5 mA     28 mW
+ * VDDO5       27 MHz  LVDS       1.8 V   15.1 mA     27 mW
+ * VDDO6     78.8 MHz  LVDS       1.8 V   15.4 mA     28 mW
+ * VDDO7   156.25 MHz  LVDS       1.8 V   15.7 mA     28 mW
+ * VDDO8       25 MHz  LVDS       1.8 V   15.1 mA     27 mW
+ * VDDO9       Unused                                      
+ *                                       --------  --------
+ *                                Total  416.5 mA    929 mW
+ * 
+ * Note:
+ * 
+ * -Tj is junction temperature. Tj must be less than 125 °C (on Si5345 Revision B) for device to comply with datasheet specifications. Tj = Ta + Theta_JA*On_Chip_Power.
+ * -Overall power includes on-chip power dissipation and adds differential load power dissipation to estimate total power requirements.
+ * -Above are estimates only: power and temperature should be measured on your PCB.
+ * -Selection of appropriate Theta-JA is required for most accurate estimate. Ideally, select 'User Specified Theta-JA' and enter a Theta-JA value based on the thermal properties of your PCB.
+ * 
+ * Settings
+ * ========
+ * 
+ * Location      Setting Name          Decimal Value      Hex Value        
+ * ------------  --------------------  -----------------  -----------------
+ * 0x000B[6:0]   I2C_ADDR              104                0x68             
+ * 0x0016[1]     LOL_ON_HOLD           1                  0x1              
+ * 0x0017[0]     SYSINCAL_INTR_MSK     0                  0x0              
+ * 0x0017[1]     LOSXAXB_INTR_MSK      0                  0x0              
+ * 0x0017[5]     SMB_TMOUT_INTR_MSK    0                  0x0              
+ * 0x0018[3:0]   LOS_INTR_MSK          14                 0xE              
+ * 0x0018[7:4]   OOF_INTR_MSK          14                 0xE              
+ * 0x0019[1]     LOL_INTR_MSK          0                  0x0              
+ * 0x0019[5]     HOLD_INTR_MSK         0                  0x0              
+ * 0x001A[5]     CAL_INTR_MSK          0                  0x0              
+ * 0x002B[3]     SPI_3WIRE             0                  0x0              
+ * 0x002B[5]     AUTO_NDIV_UPDATE      0                  0x0              
+ * 0x002C[3:0]   LOS_EN                1                  0x1              
+ * 0x002C[4]     LOSXAXB_DIS           0                  0x0              
+ * 0x002D[1:0]   LOS0_VAL_TIME         1                  0x1              
+ * 0x002D[3:2]   LOS1_VAL_TIME         0                  0x0              
+ * 0x002D[5:4]   LOS2_VAL_TIME         0                  0x0              
+ * 0x002D[7:6]   LOS3_VAL_TIME         0                  0x0              
+ * 0x002E[15:0]  LOS0_TRG_THR          59                 0x003B           
+ * 0x0030[15:0]  LOS1_TRG_THR          0                  0x0000           
+ * 0x0032[15:0]  LOS2_TRG_THR          0                  0x0000           
+ * 0x0034[15:0]  LOS3_TRG_THR          0                  0x0000           
+ * 0x0036[15:0]  LOS0_CLR_THR          59                 0x003B           
+ * 0x0038[15:0]  LOS1_CLR_THR          0                  0x0000           
+ * 0x003A[15:0]  LOS2_CLR_THR          0                  0x0000           
+ * 0x003C[15:0]  LOS3_CLR_THR          0                  0x0000           
+ * 0x003F[3:0]   OOF_EN                1                  0x1              
+ * 0x003F[7:4]   FAST_OOF_EN           1                  0x1              
+ * 0x0040[2:0]   OOF_REF_SEL           4                  0x4              
+ * 0x0041[4:0]   OOF0_DIV_SEL          11                 0x0B             
+ * 0x0042[4:0]   OOF1_DIV_SEL          0                  0x00             
+ * 0x0043[4:0]   OOF2_DIV_SEL          0                  0x00             
+ * 0x0044[4:0]   OOF3_DIV_SEL          0                  0x00             
+ * 0x0045[4:0]   OOFXO_DIV_SEL         12                 0x0C             
+ * 0x0046[7:0]   OOF0_SET_THR          100                0x64             
+ * 0x0047[7:0]   OOF1_SET_THR          0                  0x00             
+ * 0x0048[7:0]   OOF2_SET_THR          0                  0x00             
+ * 0x0049[7:0]   OOF3_SET_THR          0                  0x00             
+ * 0x004A[7:0]   OOF0_CLR_THR          100                0x64             
+ * 0x004B[7:0]   OOF1_CLR_THR          0                  0x00             
+ * 0x004C[7:0]   OOF2_CLR_THR          0                  0x00             
+ * 0x004D[7:0]   OOF3_CLR_THR          0                  0x00             
+ * 0x004E[2:0]   OOF0_DETWIN_SEL       5                  0x5              
+ * 0x004E[6:4]   OOF1_DETWIN_SEL       0                  0x0              
+ * 0x004F[2:0]   OOF2_DETWIN_SEL       0                  0x0              
+ * 0x004F[6:4]   OOF3_DETWIN_SEL       0                  0x0              
+ * 0x0050[3:0]   OOF_ON_LOS            15                 0xF              
+ * 0x0051[3:0]   FAST_OOF0_SET_THR     3                  0x3              
+ * 0x0052[3:0]   FAST_OOF1_SET_THR     0                  0x0              
+ * 0x0053[3:0]   FAST_OOF2_SET_THR     0                  0x0              
+ * 0x0054[3:0]   FAST_OOF3_SET_THR     0                  0x0              
+ * 0x0055[3:0]   FAST_OOF0_CLR_THR     3                  0x3              
+ * 0x0056[3:0]   FAST_OOF1_CLR_THR     0                  0x0              
+ * 0x0057[3:0]   FAST_OOF2_CLR_THR     0                  0x0              
+ * 0x0058[3:0]   FAST_OOF3_CLR_THR     0                  0x0              
+ * 0x0059[1:0]   FAST_OOF0_DETWIN_SEL  3                  0x3              
+ * 0x0059[3:2]   FAST_OOF1_DETWIN_SEL  0                  0x0              
+ * 0x0059[5:4]   FAST_OOF2_DETWIN_SEL  0                  0x0              
+ * 0x0059[7:6]   FAST_OOF3_DETWIN_SEL  0                  0x0              
+ * 0x005A[25:0]  OOF0_RATIO_REF        16777216           0x1000000        
+ * 0x005E[25:0]  OOF1_RATIO_REF        0                  0x0000000        
+ * 0x0062[25:0]  OOF2_RATIO_REF        0                  0x0000000        
+ * 0x0066[25:0]  OOF3_RATIO_REF        0                  0x0000000        
+ * 0x0092[1]     LOL_FST_EN            0                  0x0              
+ * 0x0093[7:4]   LOL_FST_DETWIN_SEL    0                  0x0              
+ * 0x0095[3:2]   LOL_FST_VALWIN_SEL    0                  0x0              
+ * 0x0096[7:4]   LOL_FST_SET_THR_SEL   0                  0x0              
+ * 0x0098[7:4]   LOL_FST_CLR_THR_SEL   0                  0x0              
+ * 0x009A[1]     LOL_SLOW_EN_PLL       1                  0x1              
+ * 0x009B[7:4]   LOL_SLW_DETWIN_SEL    3                  0x3              
+ * 0x009D[3:2]   LOL_SLW_VALWIN_SEL    0                  0x0              
+ * 0x009E[7:4]   LOL_SLW_SET_THR       2                  0x2              
+ * 0x00A0[7:4]   LOL_SLW_CLR_THR       0                  0x0              
+ * 0x00A2[1]     LOL_TIMER_EN          1                  0x1              
+ * 0x00A8[34:0]  LOL_CLR_DELAY         559171             0x000088843      
+ * 0x0102[0]     OUTALL_DISABLE_LOW    1                  0x1              
+ * 0x0108[0]     OUT0_PDN              0                  0x0              
+ * 0x0108[1]     OUT0_OE               1                  0x1              
+ * 0x0108[2]     OUT0_RDIV_FORCE2      0                  0x0              
+ * 0x0109[2:0]   OUT0_FORMAT           1                  0x1              
+ * 0x0109[3]     OUT0_SYNC_EN          1                  0x1              
+ * 0x0109[5:4]   OUT0_DIS_STATE        0                  0x0              
+ * 0x0109[7:6]   OUT0_CMOS_DRV         0                  0x0              
+ * 0x010A[3:0]   OUT0_CM               13                 0xD              
+ * 0x010A[6:4]   OUT0_AMPL             3                  0x3              
+ * 0x010B[2:0]   OUT0_MUX_SEL          0                  0x0              
+ * 0x010B[7:6]   OUT0_INV              0                  0x0              
+ * 0x010D[0]     OUT1_PDN              0                  0x0              
+ * 0x010D[1]     OUT1_OE               1                  0x1              
+ * 0x010D[2]     OUT1_RDIV_FORCE2      0                  0x0              
+ * 0x010E[2:0]   OUT1_FORMAT           1                  0x1              
+ * 0x010E[3]     OUT1_SYNC_EN          1                  0x1              
+ * 0x010E[5:4]   OUT1_DIS_STATE        0                  0x0              
+ * 0x010E[7:6]   OUT1_CMOS_DRV         0                  0x0              
+ * 0x010F[3:0]   OUT1_CM               13                 0xD              
+ * 0x010F[6:4]   OUT1_AMPL             3                  0x3              
+ * 0x0110[2:0]   OUT1_MUX_SEL          0                  0x0              
+ * 0x0110[7:6]   OUT1_INV              0                  0x0              
+ * 0x0112[0]     OUT2_PDN              0                  0x0              
+ * 0x0112[1]     OUT2_OE               1                  0x1              
+ * 0x0112[2]     OUT2_RDIV_FORCE2      0                  0x0              
+ * 0x0113[2:0]   OUT2_FORMAT           1                  0x1              
+ * 0x0113[3]     OUT2_SYNC_EN          1                  0x1              
+ * 0x0113[5:4]   OUT2_DIS_STATE        0                  0x0              
+ * 0x0113[7:6]   OUT2_CMOS_DRV         0                  0x0              
+ * 0x0114[3:0]   OUT2_CM               13                 0xD              
+ * 0x0114[6:4]   OUT2_AMPL             3                  0x3              
+ * 0x0115[2:0]   OUT2_MUX_SEL          0                  0x0              
+ * 0x0115[7:6]   OUT2_INV              0                  0x0              
+ * 0x0117[0]     OUT3_PDN              1                  0x1              
+ * 0x0117[1]     OUT3_OE               0                  0x0              
+ * 0x0117[2]     OUT3_RDIV_FORCE2      0                  0x0              
+ * 0x0118[2:0]   OUT3_FORMAT           1                  0x1              
+ * 0x0118[3]     OUT3_SYNC_EN          1                  0x1              
+ * 0x0118[5:4]   OUT3_DIS_STATE        0                  0x0              
+ * 0x0118[7:6]   OUT3_CMOS_DRV         0                  0x0              
+ * 0x0119[3:0]   OUT3_CM               11                 0xB              
+ * 0x0119[6:4]   OUT3_AMPL             3                  0x3              
+ * 0x011A[2:0]   OUT3_MUX_SEL          0                  0x0              
+ * 0x011A[7:6]   OUT3_INV              0                  0x0              
+ * 0x011C[0]     OUT4_PDN              0                  0x0              
+ * 0x011C[1]     OUT4_OE               1                  0x1              
+ * 0x011C[2]     OUT4_RDIV_FORCE2      0                  0x0              
+ * 0x011D[2:0]   OUT4_FORMAT           1                  0x1              
+ * 0x011D[3]     OUT4_SYNC_EN          1                  0x1              
+ * 0x011D[5:4]   OUT4_DIS_STATE        0                  0x0              
+ * 0x011D[7:6]   OUT4_CMOS_DRV         0                  0x0              
+ * 0x011E[3:0]   OUT4_CM               13                 0xD              
+ * 0x011E[6:4]   OUT4_AMPL             3                  0x3              
+ * 0x011F[2:0]   OUT4_MUX_SEL          0                  0x0              
+ * 0x011F[7:6]   OUT4_INV              0                  0x0              
+ * 0x0121[0]     OUT5_PDN              0                  0x0              
+ * 0x0121[1]     OUT5_OE               1                  0x1              
+ * 0x0121[2]     OUT5_RDIV_FORCE2      0                  0x0              
+ * 0x0122[2:0]   OUT5_FORMAT           1                  0x1              
+ * 0x0122[3]     OUT5_SYNC_EN          1                  0x1              
+ * 0x0122[5:4]   OUT5_DIS_STATE        0                  0x0              
+ * 0x0122[7:6]   OUT5_CMOS_DRV         0                  0x0              
+ * 0x0123[3:0]   OUT5_CM               13                 0xD              
+ * 0x0123[6:4]   OUT5_AMPL             3                  0x3              
+ * 0x0124[2:0]   OUT5_MUX_SEL          2                  0x2              
+ * 0x0124[7:6]   OUT5_INV              0                  0x0              
+ * 0x0126[0]     OUT6_PDN              0                  0x0              
+ * 0x0126[1]     OUT6_OE               1                  0x1              
+ * 0x0126[2]     OUT6_RDIV_FORCE2      0                  0x0              
+ * 0x0127[2:0]   OUT6_FORMAT           1                  0x1              
+ * 0x0127[3]     OUT6_SYNC_EN          1                  0x1              
+ * 0x0127[5:4]   OUT6_DIS_STATE        0                  0x0              
+ * 0x0127[7:6]   OUT6_CMOS_DRV         0                  0x0              
+ * 0x0128[3:0]   OUT6_CM               13                 0xD              
+ * 0x0128[6:4]   OUT6_AMPL             3                  0x3              
+ * 0x0129[2:0]   OUT6_MUX_SEL          3                  0x3              
+ * 0x0129[7:6]   OUT6_INV              0                  0x0              
+ * 0x012B[0]     OUT7_PDN              0                  0x0              
+ * 0x012B[1]     OUT7_OE               1                  0x1              
+ * 0x012B[2]     OUT7_RDIV_FORCE2      1                  0x1              
+ * 0x012C[2:0]   OUT7_FORMAT           1                  0x1              
+ * 0x012C[3]     OUT7_SYNC_EN          1                  0x1              
+ * 0x012C[5:4]   OUT7_DIS_STATE        0                  0x0              
+ * 0x012C[7:6]   OUT7_CMOS_DRV         0                  0x0              
+ * 0x012D[3:0]   OUT7_CM               13                 0xD              
+ * 0x012D[6:4]   OUT7_AMPL             3                  0x3              
+ * 0x012E[2:0]   OUT7_MUX_SEL          1                  0x1              
+ * 0x012E[7:6]   OUT7_INV              0                  0x0              
+ * 0x0130[0]     OUT8_PDN              0                  0x0              
+ * 0x0130[1]     OUT8_OE               1                  0x1              
+ * 0x0130[2]     OUT8_RDIV_FORCE2      0                  0x0              
+ * 0x0131[2:0]   OUT8_FORMAT           1                  0x1              
+ * 0x0131[3]     OUT8_SYNC_EN          1                  0x1              
+ * 0x0131[5:4]   OUT8_DIS_STATE        0                  0x0              
+ * 0x0131[7:6]   OUT8_CMOS_DRV         0                  0x0              
+ * 0x0132[3:0]   OUT8_CM               13                 0xD              
+ * 0x0132[6:4]   OUT8_AMPL             3                  0x3              
+ * 0x0133[2:0]   OUT8_MUX_SEL          0                  0x0              
+ * 0x0133[7:6]   OUT8_INV              0                  0x0              
+ * 0x013A[0]     OUT9_PDN              1                  0x1              
+ * 0x013A[1]     OUT9_OE               0                  0x0              
+ * 0x013A[2]     OUT9_RDIV_FORCE2      0                  0x0              
+ * 0x013B[2:0]   OUT9_FORMAT           1                  0x1              
+ * 0x013B[3]     OUT9_SYNC_EN          1                  0x1              
+ * 0x013B[5:4]   OUT9_DIS_STATE        0                  0x0              
+ * 0x013B[7:6]   OUT9_CMOS_DRV         0                  0x0              
+ * 0x013C[3:0]   OUT9_CM               11                 0xB              
+ * 0x013C[6:4]   OUT9_AMPL             3                  0x3              
+ * 0x013D[2:0]   OUT9_MUX_SEL          0                  0x0              
+ * 0x013D[7:6]   OUT9_INV              0                  0x0              
+ * 0x013F[11:0]  OUTX_ALWAYS_ON        0                  0x000            
+ * 0x0141[1]     OUT_DIS_MSK           0                  0x0              
+ * 0x0141[5]     OUT_DIS_LOL_MSK       0                  0x0              
+ * 0x0141[6]     OUT_DIS_LOSXAXB_MSK   1                  0x1              
+ * 0x0141[7]     OUT_DIS_MSK_LOS_PFD   0                  0x0              
+ * 0x0142[1]     OUT_DIS_MSK_LOL       1                  0x1              
+ * 0x0142[5]     OUT_DIS_MSK_HOLD      1                  0x1              
+ * 0x0202[31:0]  XAXB_FREQ_OFFSET      0                  0x00000000       
+ * 0x0206[1:0]   PXAXB                 0                  0x0              
+ * 0x0208[47:0]  P0_NUM                13                 0x00000000000D   
+ * 0x020E[31:0]  P0_DEN                1                  0x00000001       
+ * 0x0212[47:0]  P1_NUM                0                  0x000000000000   
+ * 0x0218[31:0]  P1_DEN                0                  0x00000000       
+ * 0x021C[47:0]  P2_NUM                0                  0x000000000000   
+ * 0x0222[31:0]  P2_DEN                0                  0x00000000       
+ * 0x0226[47:0]  P3_NUM                0                  0x000000000000   
+ * 0x022C[31:0]  P3_DEN                0                  0x00000000       
+ * 0x0231[3:0]   P0_FRACN_MODE         1                  0x1              
+ * 0x0231[4]     P0_FRACN_EN           0                  0x0              
+ * 0x0232[3:0]   P1_FRACN_MODE         1                  0x1              
+ * 0x0232[4]     P1_FRACN_EN           0                  0x0              
+ * 0x0233[3:0]   P2_FRACN_MODE         1                  0x1              
+ * 0x0233[4]     P2_FRACN_EN           0                  0x0              
+ * 0x0234[3:0]   P3_FRACN_MODE         1                  0x1              
+ * 0x0234[4]     P3_FRACN_EN           0                  0x0              
+ * 0x0235[43:0]  MXAXB_NUM             601295421440       0x08C00000000    
+ * 0x023B[31:0]  MXAXB_DEN             2147483648         0x80000000       
+ * 0x024A[23:0]  R0_REG                4                  0x000004         
+ * 0x024D[23:0]  R1_REG                3                  0x000003         
+ * 0x0250[23:0]  R2_REG                4                  0x000004         
+ * 0x0253[23:0]  R3_REG                0                  0x000000         
+ * 0x0256[23:0]  R4_REG                4                  0x000004         
+ * 0x0259[23:0]  R5_REG                2                  0x000002         
+ * 0x025C[23:0]  R6_REG                1                  0x000001         
+ * 0x025F[23:0]  R7_REG                0                  0x000000         
+ * 0x0262[23:0]  R8_REG                19                 0x000013         
+ * 0x0268[23:0]  R9_REG                0                  0x000000         
+ * 0x026B[7:0]   DESIGN_ID0            56                 0x38             
+ * 0x026C[7:0]   DESIGN_ID1            48                 0x30             
+ * 0x026D[7:0]   DESIGN_ID2            56                 0x38             
+ * 0x026E[7:0]   DESIGN_ID3            45                 0x2D             
+ * 0x026F[7:0]   DESIGN_ID4            66                 0x42             
+ * 0x0270[7:0]   DESIGN_ID5            32                 0x20             
+ * 0x0271[7:0]   DESIGN_ID6            32                 0x20             
+ * 0x0272[7:0]   DESIGN_ID7            32                 0x20             
+ * 0x0302[43:0]  N0_NUM                30064771072        0x00700000000    
+ * 0x0308[31:0]  N0_DEN                2147483648         0x80000000       
+ * 0x030C[0]     N0_UPDATE             0                  0x0              
+ * 0x030D[43:0]  N1_NUM                120259084288       0x01C00000000    
+ * 0x0313[31:0]  N1_DEN                2684354560         0xA0000000       
+ * 0x0317[0]     N1_UPDATE             0                  0x0              
+ * 0x0318[43:0]  N2_NUM                234881024000       0x036B0000000    
+ * 0x031E[31:0]  N2_DEN                2717908992         0xA2000000       
+ * 0x0322[0]     N2_UPDATE             0                  0x0              
+ * 0x0323[43:0]  N3_NUM                146800640000       0x0222E000000    
+ * 0x0329[31:0]  N3_DEN                3305111552         0xC5000000       
+ * 0x032D[0]     N3_UPDATE             0                  0x0              
+ * 0x032E[43:0]  N4_NUM                0                  0x00000000000    
+ * 0x0334[31:0]  N4_DEN                0                  0x00000000       
+ * 0x0338[0]     N4_UPDATE             0                  0x0              
+ * 0x0338[1]     N_UPDATE              0                  0x0              
+ * 0x0339[4:0]   N_FSTEP_MSK           31                 0x1F             
+ * 0x033B[43:0]  N0_FSTEPW             0                  0x00000000000    
+ * 0x0341[43:0]  N1_FSTEPW             0                  0x00000000000    
+ * 0x0347[43:0]  N2_FSTEPW             0                  0x00000000000    
+ * 0x034D[43:0]  N3_FSTEPW             0                  0x00000000000    
+ * 0x0353[43:0]  N4_FSTEPW             0                  0x00000000000    
+ * 0x0359[15:0]  N0_DELAY              0                  0x0000           
+ * 0x035B[15:0]  N1_DELAY              0                  0x0000           
+ * 0x035D[15:0]  N2_DELAY              0                  0x0000           
+ * 0x035F[15:0]  N3_DELAY              0                  0x0000           
+ * 0x0361[15:0]  N4_DELAY              0                  0x0000           
+ * 0x0487[0]     ZDM_EN                0                  0x0              
+ * 0x0487[2:1]   ZDM_IN_SEL            0                  0x0              
+ * 0x0508[5:0]   BW0_PLL               19                 0x13             
+ * 0x0509[5:0]   BW1_PLL               34                 0x22             
+ * 0x050A[5:0]   BW2_PLL               12                 0x0C             
+ * 0x050B[5:0]   BW3_PLL               11                 0x0B             
+ * 0x050C[5:0]   BW4_PLL               7                  0x07             
+ * 0x050D[5:0]   BW5_PLL               63                 0x3F             
+ * 0x050E[5:0]   FAST_BW0_PLL          22                 0x16             
+ * 0x050F[5:0]   FAST_BW1_PLL          42                 0x2A             
+ * 0x0510[5:0]   FAST_BW2_PLL          9                  0x09             
+ * 0x0511[5:0]   FAST_BW3_PLL          8                  0x08             
+ * 0x0512[5:0]   FAST_BW4_PLL          7                  0x07             
+ * 0x0513[5:0]   FAST_BW5_PLL          63                 0x3F             
+ * 0x0515[55:0]  M_NUM                 3126736191488      0x0002D800000000 
+ * 0x051C[31:0]  M_DEN                 2147483648         0x80000000       
+ * 0x0521[3:0]   M_FRAC_MODE           1                  0x1              
+ * 0x0521[4]     M_FRAC_EN             0                  0x0              
+ * 0x0521[5]     PLL_OUT_RATE_SEL      1                  0x1              
+ * 0x052A[0]     IN_SEL_REGCTRL        1                  0x1              
+ * 0x052A[3:1]   IN_SEL                0                  0x0              
+ * 0x052B[0]     FASTLOCK_AUTO_EN      1                  0x1              
+ * 0x052B[1]     FASTLOCK_MAN          0                  0x0              
+ * 0x052C[0]     HOLD_EN               1                  0x1              
+ * 0x052C[3]     HOLD_RAMP_BYP         1                  0x1              
+ * 0x052C[7:5]   HOLD_RAMP_RATE        0                  0x0              
+ * 0x052D[1]     HOLD_RAMPBYP_NOHIST   1                  0x1              
+ * 0x052E[4:0]   HOLD_HIST_LEN         25                 0x19             
+ * 0x052F[4:0]   HOLD_HIST_DELAY       25                 0x19             
+ * 0x0531[4:0]   HOLD_REF_COUNT_FRC    0                  0x00             
+ * 0x0532[23:0]  HOLD_15M_CYC_COUNT    867                0x000363         
+ * 0x0535[0]     FORCE_HOLD            0                  0x0              
+ * 0x0536[1:0]   CLK_SWITCH_MODE       0                  0x0              
+ * 0x0536[2]     HSW_EN                1                  0x1              
+ * 0x0536[3]     HSW_RAMP_BYP          1                  0x1              
+ * 0x0537[3:0]   IN_LOS_MSK            0                  0x0              
+ * 0x0537[7:4]   IN_OOF_MSK            0                  0x0              
+ * 0x0538[2:0]   IN0_PRIORITY          0                  0x0              
+ * 0x0538[6:4]   IN1_PRIORITY          0                  0x0              
+ * 0x0539[2:0]   IN2_PRIORITY          0                  0x0              
+ * 0x0539[6:4]   IN3_PRIORITY          0                  0x0              
+ * 0x0802[15:0]  FIXREGSA0             1333               0x0535           
+ * 0x0804[7:0]   FIXREGSD0             0                  0x00             
+ * 0x090E[0]     XAXB_EXTCLK_EN        0                  0x0              
+ * 0x0943[0]     IO_VDD_SEL            0                  0x0              
+ * 0x0949[3:0]   IN_EN                 1                  0x1              
+ * 0x0949[7:4]   IN_PULSED_CMOS_EN     0                  0x0              
+ * 0x094A[3:0]   INX_TO_PFD_EN         1                  0x1              
+ * 0x0A02[4:0]   N_ADD_0P5             0                  0x00             
+ * 0x0A03[4:0]   N_CLK_TO_OUTX_EN      15                 0x0F             
+ * 0x0A04[4:0]   N_PIBYP               1                  0x01             
+ * 0x0A05[4:0]   N_PDNB                15                 0x0F             
+ * 0x0B44[3:0]   PDIV_FRACN_CLK_DIS    15                 0xF              
+ * 0x0B44[5]     FRACN_CLK_DIS_PLL     1                  0x1              
+ * 0x0B46[3:0]   LOS_CLK_DIS           0                  0x0              
+ * 0x0B47[4:0]   OOF_CLK_DIS           14                 0x0E             
+ * 0x0B48[4:0]   OOF_DIV_CLK_DIS       14                 0x0E             
+ * 0x0B4A[4:0]   N_CLK_DIS             16                 0x10
+ * 
+ *
+ */
+
+#endif
\ No newline at end of file
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0803.h b/lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0808.h
similarity index 79%
rename from lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0803.h
rename to lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0808.h
index 60fd49257a..84175ff32e 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0803.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0808.h
@@ -1,69 +1,82 @@
-/*
--- Company: 		Trenz Electronic
--- Engineer: 		Oleksandr Kiyenko / John Hartfiel
- */
-
-#ifndef SRC_TE_IIC_DEFINE_H_
-#define SRC_TE_IIC_DEFINE_H_
-
-/* Board specific settings - General example*/
-
-/* use own 'main' function */
-// #define TE_STANDALONE
-
-/* Define clock chip */
-// #define CLOCK_SI5345
-// #define NVM_CODE /* for SI5345: NVM writing is limited!,  you do it on your own risk!*/
-
-#define CLOCK_SI5338
-
-
-/* IIC interface type definition (use one that pass) */
-// #define IIC_TYPE_AXI_IIC
-// #define IIC_BASE_ADDRESS	XPAR_IIC_0_BASEADDR
-
-//#define IIC_TYPE_ZYNQPS_IIC
-//#define XIICPS_DEVICE_ID	XPAR_XIICPS_0_DEVICE_ID
-
-#define IIC_TYPE_ZYNQUPS_IIC
-#define XIICPS_DEVICE_ID	XPAR_XIICPS_0_DEVICE_ID
-
-//#define IIC_TYPE_MCS_GPIO_IIC
-//#define GPIO_SDA_PIN	0
-//#define GPIO_SCL_PIN	1
-
-//#define IIC_TYPE_AXI_GPIO_IIC
-//#define GPIO_DEVICE_ID	XPAR_GPIO_0_DEVICE_ID
-//#define GPIO_CHANNEL	0
-//#define GPIO_SDA_PIN	0
-//#define GPIO_SCL_PIN	1
-
-//#define IIC_TYPE_PS_GPIO_IIC
-//#define GPIO_DEVICE_ID	XPAR_XGPIOPS_0_DEVICE_ID
-//#define GPIO_SDA_PIN	0
-//#define GPIO_SCL_PIN	1
-
-/* Define IIC clock speed */
-#define IIC_SCLK_RATE			400000
-
-
-/* UART interface type definition (use one that pass) */
-
-// #define UART_TYPE_AXI_UARTLITE
-// #define UART_DEVICE_ID			XPAR_AXI_UARTLITE_0_DEVICE_ID
-
-//#define UART_TYPE_AXI_UART16550
-//#define UART_DEVICE_ID			XPAR_UARTNS550_0_DEVICE_ID
-
-//#define UART_TYPE_ZYNQPS_UART
-//#define UART_DEVICE_ID			XPAR_XUARTPS_0_DEVICE_ID
-
-#define UART_TYPE_ZYNQUPS_UART
-#define UART_DEVICE_ID			XPAR_XUARTPS_0_DEVICE_ID
-
-//#define UART_TYPE_NO_UART
-
-/* Define UART baudrate */
-#define UART_BAUDRATE			115200
-
-#endif /* SRC_TE_IIC_DEFINE_H_ */
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+
+#ifndef SRC_TE_IIC_DEFINE_H_
+#define SRC_TE_IIC_DEFINE_H_
+
+/* Board specific settings - General example*/
+
+/* use own 'main' function */
+// #define TE_STANDALONE
+
+/* Define clock chip */
+#define CLOCK_SI5345
+// #define NVM_CODE /* for SI5345: NVM writing is limited!,  you do it on your own risk!*/
+
+//#define CLOCK_SI5338
+
+/*Define PCI_DS80PCI800*/
+//define PCI redriver configuration
+
+#define PCI_DS80PCI800
+
+/*Define PCI_DS80PCI102*/
+//define PCI redriver configuration
+
+#define PCI_DS80PCI102
+/* IIC interface type definition (use one that pass) */
+// #define IIC_TYPE_AXI_IIC
+// #define IIC_BASE_ADDRESS	XPAR_IIC_0_BASEADDR
+
+//#define IIC_TYPE_ZYNQPS_IIC
+//#define XIICPS_DEVICE_ID	XPAR_XIICPS_0_DEVICE_ID
+
+#define IIC_TYPE_ZYNQUPS_IIC
+#define XIICPS_DEVICE_ID	XPAR_XIICPS_0_DEVICE_ID
+
+#define IIC_TYPE_ZYNQUPS_IIC
+#define XIICPS1_DEVICE_ID	XPAR_XIICPS_1_DEVICE_ID
+
+#define IIC1_BASE_ADDRESS      XPAR_IIC_1_BASEADDR
+
+//#define IIC_TYPE_MCS_GPIO_IIC
+//#define GPIO_SDA_PIN	0
+//#define GPIO_SCL_PIN	1
+
+//#define IIC_TYPE_AXI_GPIO_IIC
+//#define GPIO_DEVICE_ID	XPAR_GPIO_0_DEVICE_ID
+//#define GPIO_CHANNEL	0
+//#define GPIO_SDA_PIN	0
+//#define GPIO_SCL_PIN	1
+
+//#define IIC_TYPE_PS_GPIO_IIC
+//#define GPIO_DEVICE_ID	XPAR_XGPIOPS_0_DEVICE_ID
+//#define GPIO_SDA_PIN	0
+//#define GPIO_SCL_PIN	1
+
+/* Define IIC clock speed */
+#define IIC_SCLK_RATE			400000
+
+
+/* UART interface type definition (use one that pass) */
+
+// #define UART_TYPE_AXI_UARTLITE
+// #define UART_DEVICE_ID			XPAR_AXI_UARTLITE_0_DEVICE_ID
+
+//#define UART_TYPE_AXI_UART16550
+//#define UART_DEVICE_ID			XPAR_UARTNS550_0_DEVICE_ID
+
+//#define UART_TYPE_ZYNQPS_UART
+//#define UART_DEVICE_ID			XPAR_XUARTPS_0_DEVICE_ID
+
+#define UART_TYPE_ZYNQUPS_UART
+#define UART_DEVICE_ID			XPAR_XUARTPS_0_DEVICE_ID
+
+//#define UART_TYPE_NO_UART
+
+/* Define UART baudrate */
+#define UART_BAUDRATE			115200
+
+#endif /* SRC_TE_IIC_DEFINE_H_ */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0820.h b/lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0820.h
deleted file mode 100644
index 07d8513e0e..0000000000
--- a/lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0820.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
--- Company: 		Trenz Electronic
--- Engineer: 		Oleksandr Kiyenko / John Hartfiel
- */
-
-#ifndef SRC_TE_IIC_DEFINE_H_
-#define SRC_TE_IIC_DEFINE_H_
-
-/* Board specific settings - General example*/
-
-/* use own 'main' function */
-#define TE_STANDALONE
-
-/* Define clock chip */
-// #define CLOCK_SI5345
-// #define NVM_CODE /* for SI5345: NVM writing is limited!,  you do it on your own risk!*/
-
-#define CLOCK_SI5338
-
-
-/* IIC interface type definition (use one that pass) */
-// #define IIC_TYPE_AXI_IIC
-// #define IIC_BASE_ADDRESS	XPAR_IIC_0_BASEADDR
-
-//#define IIC_TYPE_ZYNQPS_IIC
-//#define XIICPS_DEVICE_ID	XPAR_XIICPS_0_DEVICE_ID
-
-#define IIC_TYPE_ZYNQUPS_IIC
-#define XIICPS_DEVICE_ID	XPAR_XIICPS_0_DEVICE_ID
-
-//#define IIC_TYPE_MCS_GPIO_IIC
-//#define GPIO_SDA_PIN	0
-//#define GPIO_SCL_PIN	1
-
-//#define IIC_TYPE_AXI_GPIO_IIC
-//#define GPIO_DEVICE_ID	XPAR_GPIO_0_DEVICE_ID
-//#define GPIO_CHANNEL	0
-//#define GPIO_SDA_PIN	0
-//#define GPIO_SCL_PIN	1
-
-//#define IIC_TYPE_PS_GPIO_IIC
-//#define GPIO_DEVICE_ID	XPAR_XGPIOPS_0_DEVICE_ID
-//#define GPIO_SDA_PIN	0
-//#define GPIO_SCL_PIN	1
-
-/* Define IIC clock speed */
-#define IIC_SCLK_RATE			400000
-
-
-/* UART interface type definition (use one that pass) */
-
-// #define UART_TYPE_AXI_UARTLITE
-// #define UART_DEVICE_ID			XPAR_AXI_UARTLITE_0_DEVICE_ID
-
-//#define UART_TYPE_AXI_UART16550
-//#define UART_DEVICE_ID			XPAR_UARTNS550_0_DEVICE_ID
-
-//#define UART_TYPE_ZYNQPS_UART
-//#define UART_DEVICE_ID			XPAR_XUARTPS_0_DEVICE_ID
-
-#define UART_TYPE_ZYNQUPS_UART
-#define UART_DEVICE_ID			XPAR_XUARTPS_0_DEVICE_ID
-
-//#define UART_TYPE_NO_UART
-
-/* Define UART baudrate */
-#define UART_BAUDRATE			115200
-
-#endif /* SRC_TE_IIC_DEFINE_H_ */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.c b/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.c
index 45370b2278..db6fbe2eed 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.c
@@ -1,512 +1,637 @@
-/*
--- Company: 		Trenz Electronic
--- Engineer: 		Oleksandr Kiyenko / John Hartfiel
- */
-#include "te_iic_platform.h"
-#include "te_uart.h"
-
-/*----------------------------------------------------------------------------*/
-#ifdef IIC_TYPE_AXI_IIC
-int iic_init(void)
-{
-	int Status;
-	u32 StatusReg;
-
-	/* Initialize the IIC Core. */
-	Status = XIic_DynInit(IIC_BASE_ADDRESS);
-	if (Status != XST_SUCCESS) {
-		p_printf(("IIC Controller Init failure\r\n"));
-		return XST_FAILURE;
-	}
-	/* Make sure all the Fifo's are cleared and Bus is Not busy. */
-	while (((StatusReg = XIic_ReadReg(IIC_BASE_ADDRESS,
-				XIIC_SR_REG_OFFSET)) &
-				(XIIC_SR_RX_FIFO_EMPTY_MASK |
-				XIIC_SR_TX_FIFO_EMPTY_MASK |
-				XIIC_SR_BUS_BUSY_MASK)) !=
-				(XIIC_SR_RX_FIFO_EMPTY_MASK |
-				XIIC_SR_TX_FIFO_EMPTY_MASK)) {
-	}
-	return Status;
-}
-
-int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val)
-{
-	int Status;
-	u8 SentByteCount;
-	u8 WriteBuffer[2];
-
-	WriteBuffer[0] = (u8) (reg_addr);
-	WriteBuffer[1] = (u8) (reg_val);
-	Status = XST_SUCCESS;
-
-	SentByteCount = XIic_DynSend(IIC_BASE_ADDRESS, chip_addr, WriteBuffer, 2, XIIC_STOP);
-
-	if(SentByteCount != 2){	// All bits
-		Status = XST_FAILURE;
-	}
-	return Status;
-}
-
-int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *reg_val)
-{
-	u8 SentByteCount;
-	u8 ReceivedByteCount;
-	u8 WriteBuffer = reg_addr;
-
-	#ifdef DEBUG_MSG
-	p_printf(("iic_read8: addr 0x%04x\r\n", reg_addr));
-	#endif
-	SentByteCount = XIic_DynSend(IIC_BASE_ADDRESS, chip_addr, &WriteBuffer, 1, XIIC_STOP);
-	if(SentByteCount != 1){
-		return XST_FAILURE;
-	}
-	ReceivedByteCount = XIic_DynRecv(IIC_BASE_ADDRESS, chip_addr, reg_val, 1);
-	#ifdef DEBUG_MSG
-	p_printf(("iic_read8: received %d bytes = 0x%02x\r\n", ReceivedByteCount, reg_val[0]));
-	#endif
-	if(ReceivedByteCount != 1){
-		return XST_FAILURE;
-	}
-	return XST_SUCCESS;
-}
-
-void iic_delay(int delay_ms){
-	volatile int i;
-	for(i=0;i<(delay_ms*1000000);i++);
-}
-
-#endif /* IIC_TYPE_AXI_IIC */
-
-/*----------------------------------------------------------------------------*/
-#if defined(IIC_TYPE_ZYNQPS_IIC) || defined(IIC_TYPE_ZYNQUPS_IIC)
-int iic_init(void)
-{
-	XIicPs_Config *I2cCfgPtr;
-	int Status = XST_SUCCESS;
-
-	I2cCfgPtr = XIicPs_LookupConfig(XIICPS_DEVICE_ID);
-
-	if (I2cCfgPtr == NULL){
-		p_printf(("IIC Controller lookup failure\r\n"));
-		return XST_FAILURE;
-	}
-
-	Status = XIicPs_CfgInitialize(&I2cInstancePtr, I2cCfgPtr, I2cCfgPtr->BaseAddress);
-	if (Status != XST_SUCCESS) {
-		p_printf(("IIC Controller Init failure\r\n"));
-		return XST_FAILURE;
-	}
-
-	XIicPs_SetSClk(&I2cInstancePtr, IIC_SCLK_RATE);
-	return Status;
-}
-
-int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val)
-{
-    u8 WriteBuffer[10];
-	int Status;
-
-	WriteBuffer[0] = reg_addr;
-	WriteBuffer[1] = reg_val;
-    Status = XIicPs_MasterSendPolled(&I2cInstancePtr, WriteBuffer, 2, chip_addr);
-    if (Status != XST_SUCCESS) {
-		return Status;
-    }
-
-    // Wait until bus is idle to start another transfer
-    while (XIicPs_BusIsBusy(&I2cInstancePtr)) {};
-
-	return XST_SUCCESS;
-}
-
-int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *data)
-{
-	u8 wr_data;
-	wr_data = reg_addr;
-	XIicPs_MasterSendPolled(&I2cInstancePtr, &wr_data, 1, chip_addr);
-	XIicPs_MasterRecvPolled(&I2cInstancePtr, data, 1, chip_addr);
-	while (XIicPs_BusIsBusy(&I2cInstancePtr));
-	return 0;
-}
-
-void iic_delay(int delay_ms){
-	usleep(delay_ms*1000);
-}
-
-#endif /* IIC_TYPE_ZYNQPS_IIC IIC_TYPE_ZYNQUPS_IIC */
-
-/*----------------------------------------------------------------------------*/
-#ifdef IIC_TYPE_MCS_GPIO_IIC
-
-
-void gpio_set_pin(unsigned int pin, unsigned int value)
-{
-	static unsigned int gpio_shadow = 0;
-	if(value == 0)
-	{
-		gpio_shadow &= ~(1 << pin);
-	}
-	else
-	{
-		gpio_shadow |= (1 << pin);
-	}
-	XIo_Out32(GPIO_OUT_REG, gpio_shadow);
-}
-
-u8 gpio_get_pin(unsigned int pin)
-{
-	if((XIo_In32(GPIO_IN_REG) & (1 << pin)) != 0)
-	{
-		return 1;
-	}
-	return 0; 
-}
-
-int iic_init(void)
-{
-	gpio_set_pin(GPIO_SDA_PIN, 1);
-	gpio_set_pin(GPIO_SCL_PIN, 1);
-  return 0; 
-}
-
-#endif /* IIC_TYPE_MCS_GPIO_IIC */
-
-/*----------------------------------------------------------------------------*/
-#ifdef IIC_TYPE_AXI_GPIO_IIC
-int iic_init(void)
-{
-	int Status;
-	u32 dir;
-	Status = XGpio_Initialize(&Gpio, GPIO_DEVICE_ID);
-	// SCL and SDA should have PULL UP
-	dir = XGpio_GetDataDirection(&Gpio, GPIO_CHANNEL);
-	dir |= (GPIO_SDA_PIN | GPIO_SCL_PIN);
-	// Set Direction to IN
-	XGpio_SetDataDirection(&Gpio, GPIO_CHANNEL, dir);
-	// Set Values to 0
-	XGpio_DiscreteClear(&Gpio, GPIO_CHANNEL, GPIO_SDA_PIN);
-	XGpio_DiscreteClear(&Gpio, GPIO_CHANNEL, GPIO_SCL_PIN);
-
-	return Status;
-}
-
-void gpio_set_pin(unsigned int pin, unsigned int value)
-{
-	u32 dir;
-	dir = XGpio_GetDataDirection(&Gpio, GPIO_CHANNEL);
-	if(value == 0){	// Set direction to OUT
-		dir &= ~value;
-		XGpio_SetDataDirection(&Gpio, GPIO_CHANNEL, dir);
-	}
-	else{			// Set direction to IN
-		dir |= value;
-		XGpio_SetDataDirection(&Gpio, GPIO_CHANNEL, dir);
-	}
-}
-
-u8 gpio_get_pin(unsigned int pin)
-{
-	if(XGpio_DiscreteRead(&Gpio, GPIO_CHANNEL) | pin){
-		return 1;
-	}
-	else{
-		return 0;
-	}
-}
-
-#endif /* IIC_TYPE_AXI_GPIO_IIC */
-
-/*----------------------------------------------------------------------------*/
-#ifdef IIC_TYPE_PS_GPIO_IIC
-
-int iic_init(void)
-{
-	int Status;
-	XGpioPs_Config *ConfigPtr;
-
-	ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);
-	Status = XGpioPs_CfgInitialize(&Gpio, ConfigPtr, ConfigPtr->BaseAddr);
-	// Set Direction to IN
-	XGpioPs_SetDirectionPin(&Gpio, GPIO_SDA_PIN, 0);
-	XGpioPs_SetDirectionPin(&Gpio, GPIO_SCL_PIN, 0);
-	// Output disable
-	XGpioPs_SetOutputEnablePin(&Gpio, GPIO_SDA_PIN, 0);
-	XGpioPs_SetOutputEnablePin(&Gpio, GPIO_SCL_PIN, 0);
-	// Set Values to 0
-	XGpioPs_WritePin(&Gpio, GPIO_SDA_PIN, 0);
-	XGpioPs_WritePin(&Gpio, GPIO_SCL_PIN, 0);
-
-	return Status;
-}
-
-void gpio_set_pin(unsigned int pin, unsigned int value)
-{
-	if(value == 0){	// Set direction to OUT
-		// Set Direction to IN
-		XGpioPs_SetDirectionPin(&Gpio, value, 1);
-		// Output enable
-		XGpioPs_SetOutputEnablePin(&Gpio, value, 1);
-	}
-	else{			// Set direction to IN
-		// Set Direction to IN
-		XGpioPs_SetDirectionPin(&Gpio, value, 0);
-		// Output disable
-		XGpioPs_SetOutputEnablePin(&Gpio, value, 0);
-	}
-}
-
-u8 gpio_get_pin(unsigned int pin)
-{
-	if(XGpioPs_ReadPin(&Gpio, Output_Pin) | pin)
-	{
-		return 1;
-	}
-	else{
-		return 0;
-	}
-}
-
-#endif /* IIC_TYPE_PS_GPIO_IIC */
-
-/*----------------------------------------------------------------------------*/
-/* Common functions for all GPIOs implementation */
-#if defined(IIC_TYPE_MCS_GPIO_IIC) || defined(IIC_TYPE_AXI_GPIO_IIC) || defined(IIC_TYPE_PS_GPIO_IIC)
-
-void iic_dly(){
-	volatile int i;
-	for(i=0;i<(1000);i++){
-	}
-}
-
-void iic_delay(int delay_ms){
-	volatile int i;
-	for(i=0;i<(delay_ms*1000000);i++);
-}
-
-void iic_start(void)
-{
-	gpio_set_pin(GPIO_SDA_PIN, 1);	// Pull SDA High 
-	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
-	gpio_set_pin(GPIO_SDA_PIN, 0);	// pull SDA low
-	iic_dly();
-	gpio_set_pin(GPIO_SCL_PIN, 0);	// pull SCL low
-	iic_dly();
-}
-
-void iic_stop(void)
-{
-	gpio_set_pin(GPIO_SDA_PIN, 0);	// Pull SDA low
-	gpio_set_pin(GPIO_SCL_PIN, 0);	// Ensure SCL low
-	iic_dly();
-	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
-	iic_dly();
-	gpio_set_pin(GPIO_SDA_PIN, 1);	// Pull SDA High 
-	iic_dly();
-	gpio_set_pin(GPIO_SCL_PIN, 0);	// Pull SCL low
-	iic_dly();
-}
-
-void iic_send_bit(u8 value)
-{
-	gpio_set_pin(GPIO_SCL_PIN, 0);	// Ensure that SCL is low
-	gpio_set_pin(GPIO_SDA_PIN, value);	// Set data
-	iic_dly();
-	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
-	iic_dly();
-	gpio_set_pin(GPIO_SCL_PIN, 0);	// Pull SCL low
-}
-
-u8 iic_receive_bit()
-{
-	u8 rcv_data;
-	
-	gpio_set_pin(GPIO_SCL_PIN, 0);	// Ensure that SCL is low
-	gpio_set_pin(GPIO_SDA_PIN, 1);	// Pull SDA High 
-	iic_dly();
-	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
-	iic_dly();
-	rcv_data = gpio_get_pin(GPIO_SDA_PIN);
-	gpio_set_pin(GPIO_SCL_PIN, 0);	// Pull SCL low
-	return rcv_data;
-}
-
-u8 iic_write(u8 value)
-{
-	u8 i;
-	u8 shifter = value;
-	
-	for(i = 0; i < 8; i++)
-	{
-		iic_send_bit(shifter >> 7);
-		shifter = shifter << 1;
-	}
-	return iic_receive_bit();
-}
-
-u8 iic_read(u8 ack)
-{
-	u8 i, shifter;
-	
-	for (i = 0; i < 8; i++)		// loop through each bit
-	{
-		shifter = shifter << 1;
-		shifter |= iic_receive_bit();
-	}
-	iic_send_bit(ack);			// Send ACK/NACK
-	return shifter;
-}
-
-int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val)
-{
-	int Status = 0;
-	
-	iic_start();
-	Status = iic_write(chip_addr << 1);		// Chip addr & Write 
-	if(Status != 0)							// No ACK from chip
-	{
-		p_printf(("IIC Write: no ACK from Slave\r\n"));
-		return 1;
-	}
-	Status = iic_write(reg_addr);			// Register address
-	if(Status != 0)							// No ACK from chip
-	{
-		p_printf(("IIC Write: no ACK from Slave\r\n"));
-		return 1;
-	}
-	Status = iic_write(reg_val);			// Register data
-	if(Status != 0)							// No ACK from chip
-	{
-		p_printf(("IIC Write: no ACK from Slave\r\n"));
-		return 1;
-	}
-	iic_stop();
-	return 0;
-}
-
-
-int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *data)
-{
-	int Status = 0;
-	
-	iic_start();
-	Status = iic_write(chip_addr << 1);		// Chip addr & Write 
-	if(Status != 0)							// No ACK from chip
-	{
-		p_printf(("IIC Write: no ACK from Slave\r\n"));
-		return 1;
-	}
-	Status = iic_write(reg_addr);			// Register address
-	if(Status != 0)							// No ACK from chip
-	{
-		p_printf(("IIC Write: no ACK from Slave\r\n"));
-		return 1;
-	}
-	iic_start();							// Repeated start
-	Status = iic_write((chip_addr << 1) | 0x01);	// Chip addr & Read
-	if(Status != 0)							// No ACK from chip
-	{
-		return 1;
-	}
-	*data = iic_read(1);						// NACK
-	iic_stop();
-	return 0;
-}
-
-#endif
-
-/*----------------------------------------------------------------------------*/
-/* Platform independent functions */
-int iic_write8_mask(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val, unsigned char mask)
-{
-	int Status;
-	u8 rd_val;
-
-	if(mask == 0xFF){				// All bits
-		iic_write8(chip_addr, reg_addr, reg_val);
-	}
-	else{							// Write by mask
-		Status = iic_read8(chip_addr, reg_addr, &rd_val);
-		if(Status != XST_SUCCESS){
-			return Status;
-		}
-		rd_val &= ~mask;			// Clear bits to write
-		rd_val |= reg_val & mask;	// Set bits by mask
-		Status = iic_write8(chip_addr, reg_addr, rd_val);
-		if(Status != XST_SUCCESS){
-			return Status;
-		}
-	}
-	return XST_SUCCESS;
-}
-
-int iic_write16(unsigned char chip_addr, unsigned short reg_addr, unsigned char reg_val)
-{
-	int Status;
-	u8 page, addr;
-	static int _last_page = -1;
-
-	page = (u8) (reg_addr >> 8);
-	#ifdef DEBUG_MSG
-	p_printf(("iic_write16: addr 0x%04x data 0x%02x page 0x%02x (0x%02x) addr 0x%02x [%d]\r\n", reg_addr, reg_val, page, _last_page, (reg_addr & 0xFF), total++));
-	#endif
-
-	if (_last_page < 0 || _last_page != page) {		// New page
-		#ifdef DEBUG_MSG
-		p_printf(("p\r\n"));
-		#endif
-		Status = iic_write8(chip_addr, 0x01, page);
-		if (Status != XST_SUCCESS) {
-			p_printf(("iic_write16 page write failure\r\n"));
-			return XST_FAILURE;
-		}
-	}
-	_last_page = page;
-
-	#ifdef DEBUG_MSG
-	p_printf(("r\r\n"));
-	#endif
-	addr = (u8) reg_addr & 0xFF;
-	Status = iic_write8(chip_addr, addr, reg_val);
-	if (Status != XST_SUCCESS) {
-		p_printf(("iic_write16 reg write failure\r\n"));
-		return XST_FAILURE;
-	}
-	return Status;
-}
-
-int iic_read16(unsigned char chip_addr, unsigned short reg_addr, unsigned char *reg_val)
-{
-	int Status;
-	u8 page, addr;
-	static int _last_page = -1;
-
-	page = (u8) (reg_addr >> 8);
-	#ifdef DEBUG_MSG
-	p_printf(("iic_read16: addr 0x%04x page 0x%02x (0x%02x) addr 0x%02x\r\n", reg_addr, page, _last_page, (reg_addr & 0xFF)));
-	#endif
-
-	if (_last_page < 0 || _last_page != page) {		// New page
-		#ifdef DEBUG_MSG
-		p_printf(("p\r\n"));
-		#endif
-		Status = iic_write8(chip_addr, 0x01, page);
-		if (Status != XST_SUCCESS) {
-			p_printf(("iic_read16 page write failure\r\n"));
-			return XST_FAILURE;
-		}
-	}
-	_last_page = page;
-
-	#ifdef DEBUG_MSG
-	p_printf(("r\r\n"));
-	#endif
-	addr = (u8) reg_addr & 0xFF;
-	Status = iic_read8(chip_addr, addr, reg_val);
-	if (Status != XST_SUCCESS) {
-		p_printf(("iic_read16 reg read failure\r\n"));
-		return XST_FAILURE;
-	}
-	return Status;
-}
-/*----------------------------------------------------------------------------*/
+/*
+-- Company: 		Trenz Electronic Red Wire Technologies
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel Toby Flynn
+ */
+#include "te_iic_platform.h"
+#include "te_uart.h"
+
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_AXI_IIC
+int iic_init(void)
+{
+	int Status;
+	u32 StatusReg;
+
+	/* Initialize the IIC Core. */
+	Status = XIic_DynInit(IIC_BASE_ADDRESS);
+	if (Status != XST_SUCCESS) {
+		p_printf(("IIC Controller Init failure\r\n"));
+		return XST_FAILURE;
+	}
+	/* Make sure all the Fifo's are cleared and Bus is Not busy. */
+	while (((StatusReg = XIic_ReadReg(IIC_BASE_ADDRESS,
+				XIIC_SR_REG_OFFSET)) &
+				(XIIC_SR_RX_FIFO_EMPTY_MASK |
+				XIIC_SR_TX_FIFO_EMPTY_MASK |
+				XIIC_SR_BUS_BUSY_MASK)) !=
+				(XIIC_SR_RX_FIFO_EMPTY_MASK |
+				XIIC_SR_TX_FIFO_EMPTY_MASK)) {
+	}
+	return Status;
+}
+
+int iic1_init(void)
+{
+    int Status;
+    u32 StatusReg;
+    
+    /* Initialize the IIC Core. */
+    Status = XIic_DynInit(IIC1_BASE_ADDRESS);
+    if (Status != XST_SUCCESS) {
+        p_printf(("IIC Controller Init failure\r\n"));
+        return XST_FAILURE;
+    }
+    /* Make sure all the Fifo's are cleared and Bus is Not busy. */
+    while (((StatusReg = XIic_ReadReg(IIC1_BASE_ADDRESS,
+        XIIC_SR_REG_OFFSET)) &
+        (XIIC_SR_RX_FIFO_EMPTY_MASK |
+        XIIC_SR_TX_FIFO_EMPTY_MASK |
+        XIIC_SR_BUS_BUSY_MASK)) !=
+        (XIIC_SR_RX_FIFO_EMPTY_MASK |
+        XIIC_SR_TX_FIFO_EMPTY_MASK)) {
+        }
+        return Status;
+}
+
+int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val)
+{
+	int Status;
+	u8 SentByteCount;
+	u8 WriteBuffer[2];
+
+	WriteBuffer[0] = (u8) (reg_addr);
+	WriteBuffer[1] = (u8) (reg_val);
+	Status = XST_SUCCESS;
+
+	SentByteCount = XIic_DynSend(IIC_BASE_ADDRESS, chip_addr, WriteBuffer, 2, XIIC_STOP);
+
+	if(SentByteCount != 2){	// All bits
+		Status = XST_FAILURE;
+	}
+	return Status;
+}
+
+int iic1_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val)
+{
+    int Status;
+    u8 SentByteCount;
+    u8 WriteBuffer[2];
+    
+    WriteBuffer[0] = (u8) (reg_addr);
+    WriteBuffer[1] = (u8) (reg_val);
+    Status = XST_SUCCESS;
+    
+    SentByteCount = XIic_DynSend(IIC1_BASE_ADDRESS, chip_addr, WriteBuffer, 2, XIIC_STOP);
+    
+    if(SentByteCount != 2){	// All bits
+        Status = XST_FAILURE;
+    }
+    return Status;
+}
+
+int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *reg_val)
+{
+	u8 SentByteCount;
+	u8 ReceivedByteCount;
+	u8 WriteBuffer = reg_addr;
+
+	#ifdef DEBUG_MSG
+	p_printf(("iic_read8: addr 0x%04x\r\n", reg_addr));
+	#endif
+	SentByteCount = XIic_DynSend(IIC_BASE_ADDRESS, chip_addr, &WriteBuffer, 1, XIIC_STOP);
+	if(SentByteCount != 1){
+		return XST_FAILURE;
+	}
+	ReceivedByteCount = XIic_DynRecv(IIC_BASE_ADDRESS, chip_addr, reg_val, 1);
+	#ifdef DEBUG_MSG
+	p_printf(("iic_read8: received %d bytes = 0x%02x\r\n", ReceivedByteCount, reg_val[0]));
+	#endif
+	if(ReceivedByteCount != 1){
+		return XST_FAILURE;
+	}
+	return XST_SUCCESS;
+}
+
+int iic1_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *reg_val)
+{
+    u8 SentByteCount;
+    u8 ReceivedByteCount;
+    u8 WriteBuffer = reg_addr;
+    
+    #ifdef DEBUG_MSG
+    p_printf(("iic_read8: addr 0x%04x\r\n", reg_addr));
+    #endif
+    SentByteCount = XIic_DynSend(IIC1_BASE_ADDRESS, chip_addr, &WriteBuffer, 1, XIIC_STOP);
+    if(SentByteCount != 1){
+        return XST_FAILURE;
+    }
+    ReceivedByteCount = XIic_DynRecv(IIC1_BASE_ADDRESS, chip_addr, reg_val, 1);
+    #ifdef DEBUG_MSG
+    p_printf(("iic_read8: received %d bytes = 0x%02x\r\n", ReceivedByteCount, reg_val[0]));
+    #endif
+    if(ReceivedByteCount != 1){
+        return XST_FAILURE;
+    }
+    return XST_SUCCESS;
+}
+
+void iic_delay(int delay_ms){
+	volatile int i;
+	for(i=0;i<(delay_ms*1000000);i++);
+}
+
+void iic1_delay(int delay_ms){
+    volatile int i;
+    for(i=0;i<(delay_ms*1000000);i++);
+}
+
+
+#endif /* IIC_TYPE_AXI_IIC */
+
+/*----------------------------------------------------------------------------*/
+#if defined(IIC_TYPE_ZYNQPS_IIC) || defined(IIC_TYPE_ZYNQUPS_IIC)
+int iic_init(void)
+{
+	XIicPs_Config *I2cCfgPtr;
+	int Status = XST_SUCCESS;
+
+	I2cCfgPtr = XIicPs_LookupConfig(XIICPS_DEVICE_ID);
+
+	if (I2cCfgPtr == NULL){
+		p_printf(("IIC Controller lookup failure\r\n"));
+		return XST_FAILURE;
+	}
+
+	Status = XIicPs_CfgInitialize(&I2cInstancePtr, I2cCfgPtr, I2cCfgPtr->BaseAddress);
+	if (Status != XST_SUCCESS) {
+		p_printf(("IIC Controller Init failure\r\n"));
+		return XST_FAILURE;
+	}
+
+	XIicPs_SetSClk(&I2cInstancePtr, IIC_SCLK_RATE);
+	return Status;
+}
+
+int iic1_init(void)
+{
+    XIicPs_Config *I2c1CfgPtr;
+    int Status = XST_SUCCESS;
+    
+    I2c1CfgPtr = XIicPs_LookupConfig(XIICPS1_DEVICE_ID);
+    
+    if (I2c1CfgPtr == NULL){
+        p_printf(("IIC Controller lookup failure\r\n"));
+        return XST_FAILURE;
+    }
+    
+    Status = XIicPs_CfgInitialize(&I2c1InstancePtr, I2c1CfgPtr, I2c1CfgPtr->BaseAddress);
+    if (Status != XST_SUCCESS) {
+        p_printf(("IIC Controller Init failure\r\n"));
+        return XST_FAILURE;
+    }
+    
+    XIicPs_SetSClk(&I2c1InstancePtr, IIC_SCLK_RATE);
+    return Status;
+}
+
+int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val)
+{
+    u8 WriteBuffer[10];
+	int Status;
+
+	WriteBuffer[0] = reg_addr;
+	WriteBuffer[1] = reg_val;
+    Status = XIicPs_MasterSendPolled(&I2cInstancePtr, WriteBuffer, 2, chip_addr);
+    if (Status != XST_SUCCESS) {
+		return Status;
+    }
+
+    // Wait until bus is idle to start another transfer
+    while (XIicPs_BusIsBusy(&I2cInstancePtr)) {};
+
+	return XST_SUCCESS;
+}
+
+int iic1_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val)
+{
+    u8 WriteBuffer[10];
+    int Status;
+    
+    WriteBuffer[0] = reg_addr;
+    WriteBuffer[1] = reg_val;
+    Status = XIicPs_MasterSendPolled(&I2c1InstancePtr, WriteBuffer, 2, chip_addr);
+    if (Status != XST_SUCCESS) {
+        return Status;
+    }
+    
+    // Wait until bus is idle to start another transfer
+    while (XIicPs_BusIsBusy(&I2c1InstancePtr)) {};
+    
+    return XST_SUCCESS;
+}
+
+
+int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *data)
+{
+	u8 wr_data;
+	wr_data = reg_addr;
+	XIicPs_MasterSendPolled(&I2cInstancePtr, &wr_data, 1, chip_addr);
+	XIicPs_MasterRecvPolled(&I2cInstancePtr, data, 1, chip_addr);
+	while (XIicPs_BusIsBusy(&I2cInstancePtr));
+	return 0;
+}
+
+int iic1_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *data)
+{
+    u8 wr_data;
+    wr_data = reg_addr;
+    XIicPs_MasterSendPolled(&I2c1InstancePtr, &wr_data, 1, chip_addr);
+    XIicPs_MasterRecvPolled(&I2c1InstancePtr, data, 1, chip_addr);
+    while (XIicPs_BusIsBusy(&I2c1InstancePtr));
+    return 0;
+}
+
+void iic_delay(int delay_ms){
+	usleep(delay_ms*1000);
+}
+
+void iic1_delay(int delay_ms){
+    usleep(delay_ms*1000);
+}
+
+#endif /* IIC_TYPE_ZYNQPS_IIC IIC_TYPE_ZYNQUPS_IIC */
+
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_MCS_GPIO_IIC
+
+
+void gpio_set_pin(unsigned int pin, unsigned int value)
+{
+	static unsigned int gpio_shadow = 0;
+	if(value == 0)
+	{
+		gpio_shadow &= ~(1 << pin);
+	}
+	else
+	{
+		gpio_shadow |= (1 << pin);
+	}
+	XIo_Out32(GPIO_OUT_REG, gpio_shadow);
+}
+
+u8 gpio_get_pin(unsigned int pin)
+{
+	if((XIo_In32(GPIO_IN_REG) & (1 << pin)) != 0)
+	{
+		return 1;
+	}
+	return 0; 
+}
+
+int iic_init(void)
+{
+	gpio_set_pin(GPIO_SDA_PIN, 1);
+	gpio_set_pin(GPIO_SCL_PIN, 1);
+  return 0; 
+}
+
+#endif /* IIC_TYPE_MCS_GPIO_IIC */
+
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_AXI_GPIO_IIC
+int iic_init(void)
+{
+	int Status;
+	u32 dir;
+	Status = XGpio_Initialize(&Gpio, GPIO_DEVICE_ID);
+	// SCL and SDA should have PULL UP
+	dir = XGpio_GetDataDirection(&Gpio, GPIO_CHANNEL);
+	dir |= (GPIO_SDA_PIN | GPIO_SCL_PIN);
+	// Set Direction to IN
+	XGpio_SetDataDirection(&Gpio, GPIO_CHANNEL, dir);
+	// Set Values to 0
+	XGpio_DiscreteClear(&Gpio, GPIO_CHANNEL, GPIO_SDA_PIN);
+	XGpio_DiscreteClear(&Gpio, GPIO_CHANNEL, GPIO_SCL_PIN);
+
+	return Status;
+}
+
+void gpio_set_pin(unsigned int pin, unsigned int value)
+{
+	u32 dir;
+	dir = XGpio_GetDataDirection(&Gpio, GPIO_CHANNEL);
+	if(value == 0){	// Set direction to OUT
+		dir &= ~value;
+		XGpio_SetDataDirection(&Gpio, GPIO_CHANNEL, dir);
+	}
+	else{			// Set direction to IN
+		dir |= value;
+		XGpio_SetDataDirection(&Gpio, GPIO_CHANNEL, dir);
+	}
+}
+
+u8 gpio_get_pin(unsigned int pin)
+{
+	if(XGpio_DiscreteRead(&Gpio, GPIO_CHANNEL) | pin){
+		return 1;
+	}
+	else{
+		return 0;
+	}
+}
+
+#endif /* IIC_TYPE_AXI_GPIO_IIC */
+
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_PS_GPIO_IIC
+
+int iic_init(void)
+{
+	int Status;
+	XGpioPs_Config *ConfigPtr;
+
+	ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);
+	Status = XGpioPs_CfgInitialize(&Gpio, ConfigPtr, ConfigPtr->BaseAddr);
+	// Set Direction to IN
+	XGpioPs_SetDirectionPin(&Gpio, GPIO_SDA_PIN, 0);
+	XGpioPs_SetDirectionPin(&Gpio, GPIO_SCL_PIN, 0);
+	// Output disable
+	XGpioPs_SetOutputEnablePin(&Gpio, GPIO_SDA_PIN, 0);
+	XGpioPs_SetOutputEnablePin(&Gpio, GPIO_SCL_PIN, 0);
+	// Set Values to 0
+	XGpioPs_WritePin(&Gpio, GPIO_SDA_PIN, 0);
+	XGpioPs_WritePin(&Gpio, GPIO_SCL_PIN, 0);
+
+	return Status;
+}
+
+void gpio_set_pin(unsigned int pin, unsigned int value)
+{
+	if(value == 0){	// Set direction to OUT
+		// Set Direction to IN
+		XGpioPs_SetDirectionPin(&Gpio, value, 1);
+		// Output enable
+		XGpioPs_SetOutputEnablePin(&Gpio, value, 1);
+	}
+	else{			// Set direction to IN
+		// Set Direction to IN
+		XGpioPs_SetDirectionPin(&Gpio, value, 0);
+		// Output disable
+		XGpioPs_SetOutputEnablePin(&Gpio, value, 0);
+	}
+}
+
+u8 gpio_get_pin(unsigned int pin)
+{
+	if(XGpioPs_ReadPin(&Gpio, Output_Pin) | pin)
+	{
+		return 1;
+	}
+	else{
+		return 0;
+	}
+}
+
+#endif /* IIC_TYPE_PS_GPIO_IIC */
+
+/*----------------------------------------------------------------------------*/
+/* Common functions for all GPIOs implementation */
+#if defined(IIC_TYPE_MCS_GPIO_IIC) || defined(IIC_TYPE_AXI_GPIO_IIC) || defined(IIC_TYPE_PS_GPIO_IIC)
+
+void iic_dly(){
+	volatile int i;
+	for(i=0;i<(1000);i++){
+	}
+}
+
+void iic_delay(int delay_ms){
+	volatile int i;
+	for(i=0;i<(delay_ms*1000000);i++);
+}
+
+void iic_start(void)
+{
+	gpio_set_pin(GPIO_SDA_PIN, 1);	// Pull SDA High 
+	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
+	gpio_set_pin(GPIO_SDA_PIN, 0);	// pull SDA low
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// pull SCL low
+	iic_dly();
+}
+
+void iic_stop(void)
+{
+	gpio_set_pin(GPIO_SDA_PIN, 0);	// Pull SDA low
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Ensure SCL low
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
+	iic_dly();
+	gpio_set_pin(GPIO_SDA_PIN, 1);	// Pull SDA High 
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Pull SCL low
+	iic_dly();
+}
+
+void iic_send_bit(u8 value)
+{
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Ensure that SCL is low
+	gpio_set_pin(GPIO_SDA_PIN, value);	// Set data
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Pull SCL low
+}
+
+u8 iic_receive_bit()
+{
+	u8 rcv_data;
+	
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Ensure that SCL is low
+	gpio_set_pin(GPIO_SDA_PIN, 1);	// Pull SDA High 
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
+	iic_dly();
+	rcv_data = gpio_get_pin(GPIO_SDA_PIN);
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Pull SCL low
+	return rcv_data;
+}
+
+u8 iic_write(u8 value)
+{
+	u8 i;
+	u8 shifter = value;
+	
+	for(i = 0; i < 8; i++)
+	{
+		iic_send_bit(shifter >> 7);
+		shifter = shifter << 1;
+	}
+	return iic_receive_bit();
+}
+
+u8 iic_read(u8 ack)
+{
+	u8 i, shifter;
+	
+	for (i = 0; i < 8; i++)		// loop through each bit
+	{
+		shifter = shifter << 1;
+		shifter |= iic_receive_bit();
+	}
+	iic_send_bit(ack);			// Send ACK/NACK
+	return shifter;
+}
+
+int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val)
+{
+	int Status = 0;
+	
+	iic_start();
+	Status = iic_write(chip_addr << 1);		// Chip addr & Write 
+	if(Status != 0)							// No ACK from chip
+	{
+		p_printf(("IIC Write: no ACK from Slave\r\n"));
+		return 1;
+	}
+	Status = iic_write(reg_addr);			// Register address
+	if(Status != 0)							// No ACK from chip
+	{
+		p_printf(("IIC Write: no ACK from Slave\r\n"));
+		return 1;
+	}
+	Status = iic_write(reg_val);			// Register data
+	if(Status != 0)							// No ACK from chip
+	{
+		p_printf(("IIC Write: no ACK from Slave\r\n"));
+		return 1;
+	}
+	iic_stop();
+	return 0;
+}
+
+
+int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *data)
+{
+	int Status = 0;
+	
+	iic_start();
+	Status = iic_write(chip_addr << 1);		// Chip addr & Write 
+	if(Status != 0)							// No ACK from chip
+	{
+		p_printf(("IIC Write: no ACK from Slave\r\n"));
+		return 1;
+	}
+	Status = iic_write(reg_addr);			// Register address
+	if(Status != 0)							// No ACK from chip
+	{
+		p_printf(("IIC Write: no ACK from Slave\r\n"));
+		return 1;
+	}
+	iic_start();							// Repeated start
+	Status = iic_write((chip_addr << 1) | 0x01);	// Chip addr & Read
+	if(Status != 0)							// No ACK from chip
+	{
+		return 1;
+	}
+	*data = iic_read(1);						// NACK
+	iic_stop();
+	return 0;
+}
+
+#endif
+
+/*----------------------------------------------------------------------------*/
+/* Platform independent functions */
+int iic_write8_mask(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val, unsigned char mask)
+{
+	int Status;
+	u8 rd_val;
+
+	if(mask == 0xFF){				// All bits
+		iic_write8(chip_addr, reg_addr, reg_val);
+	}
+	else{							// Write by mask
+		Status = iic_read8(chip_addr, reg_addr, &rd_val);
+		if(Status != XST_SUCCESS){
+			return Status;
+		}
+		rd_val &= ~mask;			// Clear bits to write
+		rd_val |= reg_val & mask;	// Set bits by mask
+		Status = iic_write8(chip_addr, reg_addr, rd_val);
+		if(Status != XST_SUCCESS){
+			return Status;
+		}
+	}
+	return XST_SUCCESS;
+}
+
+int iic_write16(unsigned char chip_addr, unsigned short reg_addr, unsigned char reg_val)
+{
+	int Status;
+	u8 page, addr;
+	static int _last_page = -1;
+
+	page = (u8) (reg_addr >> 8);
+	#ifdef DEBUG_MSG
+	p_printf(("iic_write16: addr 0x%04x data 0x%02x page 0x%02x (0x%02x) addr 0x%02x [%d]\r\n", reg_addr, reg_val, page, _last_page, (reg_addr & 0xFF), total++));
+	#endif
+
+	if (_last_page < 0 || _last_page != page) {		// New page
+		#ifdef DEBUG_MSG
+		p_printf(("p\r\n"));
+		#endif
+		Status = iic_write8(chip_addr, 0x01, page);
+		if (Status != XST_SUCCESS) {
+			p_printf(("iic_write16 page write failure\r\n"));
+			return XST_FAILURE;
+		}
+	}
+	_last_page = page;
+
+	#ifdef DEBUG_MSG
+	p_printf(("r\r\n"));
+	#endif
+	addr = (u8) reg_addr & 0xFF;
+	Status = iic_write8(chip_addr, addr, reg_val);
+	if (Status != XST_SUCCESS) {
+		p_printf(("iic_write16 reg write failure\r\n"));
+		return XST_FAILURE;
+	}
+	return Status;
+}
+
+int iic_read16(unsigned char chip_addr, unsigned short reg_addr, unsigned char *reg_val)
+{
+	int Status;
+	u8 page, addr;
+	static int _last_page = -1;
+
+	page = (u8) (reg_addr >> 8);
+	#ifdef DEBUG_MSG
+	p_printf(("iic_read16: addr 0x%04x page 0x%02x (0x%02x) addr 0x%02x\r\n", reg_addr, page, _last_page, (reg_addr & 0xFF)));
+	#endif
+
+	if (_last_page < 0 || _last_page != page) {		// New page
+		#ifdef DEBUG_MSG
+		p_printf(("p\r\n"));
+		#endif
+		Status = iic_write8(chip_addr, 0x01, page);
+		if (Status != XST_SUCCESS) {
+			p_printf(("iic_read16 page write failure\r\n"));
+			return XST_FAILURE;
+		}
+	}
+	_last_page = page;
+
+	#ifdef DEBUG_MSG
+	p_printf(("r\r\n"));
+	#endif
+	addr = (u8) reg_addr & 0xFF;
+	Status = iic_read8(chip_addr, addr, reg_val);
+	if (Status != XST_SUCCESS) {
+		p_printf(("iic_read16 reg read failure\r\n"));
+		return XST_FAILURE;
+	}
+	return Status;
+}
+/*----------------------------------------------------------------------------*/
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.h b/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.h
index 3df35d951f..1afe8557da 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.h
@@ -1,62 +1,72 @@
-/*
--- Company: 		Trenz Electronic
--- Engineer: 		Oleksandr Kiyenko / John Hartfiel
- */
-#ifndef IIC_PLATFORM_H_
-#define IIC_PLATFORM_H_
-#include "xparameters.h"
-
-/* Include board specific settings */
-// #include "te_iic_define.h"
-#include "te_iic_define_te0803.h"
-// #include "te_iic_define_te0820.h"
-// #include "te_iic_define_te0712.h"
-
-/* Enable extra Debug messages */
-//#define DEBUG_MSG
-/*----------------------------------------------------------------------------*/
-int iic_init(void);
-int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val);
-int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *reg_val);
-int iic_write8_mask(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val, unsigned char mask);
-int iic_write16(unsigned char chip_addr, unsigned short reg_addr, unsigned char reg_val);
-int iic_read16(unsigned char chip_addr, unsigned short reg_addr, unsigned char *reg_val);
-void iic_delay(int delay_ms);
-/*----------------------------------------------------------------------------*/
-#ifdef IIC_TYPE_AXI_IIC
-#include "xiic.h"
-#endif /* IIC_TYPE_AXI_IIC */
-/*----------------------------------------------------------------------------*/
-#ifdef IIC_TYPE_ZYNQPS_IIC
-#include "xiicps.h"
-#include <unistd.h>
-#include <stdio.h>
-XIicPs I2cInstancePtr;
-#endif /* IIC_TYPE_ZYNQPS_IIC */
-/*----------------------------------------------------------------------------*/
-#ifdef IIC_TYPE_ZYNQUPS_IIC
-#include "xiicps.h"
-#include <sleep.h>
-#include <stdio.h>
-XIicPs I2cInstancePtr;
-#endif /* IIC_TYPE_ZYNQUPS_IIC */
-/*----------------------------------------------------------------------------*/
-#ifdef IIC_TYPE_MCS_GPIO_IIC
-#include "xiomodule_l.h"
-#include "xstatus.h"
-#include "xio.h"
-#define GPIO_OUT_REG	XPAR_IOMODULE_SINGLE_BASEADDR + XGO_OUT_OFFSET
-#define GPIO_IN_REG		XPAR_IOMODULE_SINGLE_BASEADDR + XGI_IN_OFFSET
-#endif /* IIC_TYPE_MCS_GPIO_IIC */
-/*----------------------------------------------------------------------------*/
-#ifdef IIC_TYPE_AXI_GPIO_IIC
-#include "xgpio.h"
-XGpio Gpio;
-#endif /* IIC_TYPE_AXI_GPIO_IIC */
-/*----------------------------------------------------------------------------*/
-#ifdef IIC_TYPE_PS_GPIO_IIC
-#include "xgpiops.h"
-XGpioPs Gpio;
-#endif /* IIC_TYPE_PS_GPIO_IIC */
-/*----------------------------------------------------------------------------*/
-#endif /* IIC_PLATFORM_H_ */
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+#ifndef IIC_PLATFORM_H_
+#define IIC_PLATFORM_H_
+#include "xparameters.h"
+
+/* Include board specific settings */
+// #include "te_iic_define.h"
+#include "te_iic_define_te0808.h"
+// #include "te_iic_define_te0820.h"
+// #include "te_iic_define_te0712.h"
+
+/* Enable extra Debug messages */
+//#define DEBUG_MSG
+/*----------------------------------------------------------------------------*/
+int iic_init(void);
+int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val);
+int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *reg_val);
+int iic_write8_mask(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val, unsigned char mask);
+int iic_write16(unsigned char chip_addr, unsigned short reg_addr, unsigned char reg_val);
+int iic_read16(unsigned char chip_addr, unsigned short reg_addr, unsigned char *reg_val);
+void iic_delay(int delay_ms);
+
+int iic1_init(void);
+int iic1_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val);
+int iic1_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *reg_val);
+int iic1_write8_mask(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val, unsigned char mask);
+int iic1_write16(unsigned char chip_addr, unsigned short reg_addr, unsigned char reg_val);
+int iic1_read16(unsigned char chip_addr, unsigned short reg_addr, unsigned char *reg_val);
+void iic1_delay(int delay_ms);
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_AXI_IIC
+#include "xiic.h"
+#endif /* IIC_TYPE_AXI_IIC */
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_ZYNQPS_IIC
+#include "xiicps.h"
+#include <unistd.h>
+#include <stdio.h>
+XIicPs I2cInstancePtr;
+XIicPs I2c1InstancePtr;
+#endif /* IIC_TYPE_ZYNQPS_IIC */
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_ZYNQUPS_IIC
+#include "xiicps.h"
+#include <sleep.h>
+#include <stdio.h>
+XIicPs I2cInstancePtr;
+XIicPs I2c1InstancePtr;
+#endif /* IIC_TYPE_ZYNQUPS_IIC */
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_MCS_GPIO_IIC
+#include "xiomodule_l.h"
+#include "xstatus.h"
+#include "xio.h"
+#define GPIO_OUT_REG	XPAR_IOMODULE_SINGLE_BASEADDR + XGO_OUT_OFFSET
+#define GPIO_IN_REG		XPAR_IOMODULE_SINGLE_BASEADDR + XGI_IN_OFFSET
+#endif /* IIC_TYPE_MCS_GPIO_IIC */
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_AXI_GPIO_IIC
+#include "xgpio.h"
+XGpio Gpio;
+#endif /* IIC_TYPE_AXI_GPIO_IIC */
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_PS_GPIO_IIC
+#include "xgpiops.h"
+XGpioPs Gpio;
+#endif /* IIC_TYPE_PS_GPIO_IIC */
+/*----------------------------------------------------------------------------*/
+#endif /* IIC_PLATFORM_H_ */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_si534x.c b/lib/sw_apps/zynqmp_fsbl/src/te_si534x.c
new file mode 100644
index 0000000000..f019573c6e
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_si534x.c
@@ -0,0 +1,232 @@
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+#include "te_si534x.h"
+
+#ifdef CLOCK_SI5345
+
+#include "te_uart.h"
+#include "te_Si5345-Registers.h"
+
+
+
+int si534x_version(unsigned char chip_addr){
+	unsigned char val;
+	int Status;
+	  Status = iic_read16(chip_addr, 0x0003, &val);
+	  xil_printf("SI%x",val);
+
+	  Status = iic_read16(chip_addr, 0x0002, &val);
+	  xil_printf("%x",val);
+
+	  Status = iic_read16(chip_addr, 0x0005, &val);
+    if (val==0) {
+      xil_printf("-A\r\n");
+    } else if (val==1) {
+      xil_printf("-B\r\n");
+    } else if (val==2) {
+      xil_printf("-C\r\n");
+    } else if (val==3) {
+      xil_printf("-D\r\n");
+    } else {
+      xil_printf("-%x\r\n",val);
+    }
+
+	  return Status;
+}
+
+int si534x_status_wait(unsigned char chip_addr){
+	unsigned char valF,valC,valE,valD,val11;
+	unsigned int  cnt=0, tmp;
+	int Status;
+  
+  (void)usleep(0x5U);
+  
+  Status = iic_read16(chip_addr, 0x000C, &valC);
+  Status = iic_read16(chip_addr, 0x000E, &valE);
+  Status = iic_read16(chip_addr, 0x000D, &valD);
+  Status = iic_read16(chip_addr, 0x0011, &val11);
+  tmp = 1;
+  // Wait until internal calibration is not busy
+  while (tmp ==1) {
+    cnt=cnt+0x100U ;
+    (void)usleep(0x100U);
+    Status = iic_read16(chip_addr, 0x000F, &valC);
+    Status = iic_read16(chip_addr, 0x000F, &valF);
+    tmp =((((valF) & (0x10))>>5) | (valC) & (0x01));
+    if ((cnt % 0x100U) == 0) {
+      xil_printf("Status   0xC:0x%x, 0xE:0x%x, 0xD:0x%x, 0x11:%x, 0xF:%x (...waiting for calibration...%i us).\r",valC,valE,valD,val11,valF,cnt);
+    }
+    
+    if (cnt >= TIME_CHECK_PLL_CONFIG_US) {
+        xil_printf("Status   0xC:0x%x, 0xE:0x%x, 0xD:0x%x, 0x11:%x, 0xF:%x (...calibration not finished after %i us...exit...).\r\n",valC,valE,valD,val11,valF,cnt);
+        xil_printf("Status 0xC:0x%x(cal bit0:%i) and 0xF:%x(cal bit5:%i) will be checked one time again after %i us\r\n",valC,((valC) & (0x01)),valF,tmp,DELAY_AFTER_PLL_CONFIG_US);
+        tmp = 0;
+    }
+  }
+   //sleep need for PCIe
+  (void)usleep(DELAY_AFTER_PLL_CONFIG_US);
+    
+  Status = iic_read16(chip_addr, 0x000F, &valF);
+  Status = iic_read16(chip_addr, 0x000C, &valC);
+  Status = iic_read16(chip_addr, 0x000E, &valE);
+  Status = iic_read16(chip_addr, 0x000D, &valD);
+  Status = iic_read16(chip_addr, 0x0011, &val11);
+  xil_printf("PLL Status Register   0xC:0x%x, 0xE:0x%x, 0xD:0x%x, 0x11:%x, 0xF:%x.\r\n",valC,valE,valD,val11,valF);
+
+	return Status;
+}
+
+int si534x_init(unsigned char chip_addr){
+	int i, Status;
+	unsigned char val;
+	unsigned short addr;
+
+    // p_printf(("Si534x Init Start.\r\n"));
+    // iic_init();
+    p_printf(("Si534x Init Registers Write.\r\n"));
+#ifdef DEBUG_REG
+  unsigned char readback_test;
+#endif
+  
+#ifdef SI5345_REVB_REG_CONFIG_NUM_REGS
+
+    for (i=0; i<SI5345_REVB_REG_CONFIG_NUM_REGS; ++i) {
+      val = si5345_revb_registers[i].value;
+      addr = si5345_revb_registers[i].address;
+      Status = iic_write16(chip_addr, addr, val);
+      if(Status != XST_SUCCESS) {
+          p_printf(("Couldn't write value 0x%02X to address 0x%04X.\n", val, addr));
+          p_printf(("There were %d succesful I2C writes so far.\n", i));
+          return Status;
+      }
+      #ifdef DEBUG_REG
+        Status = iic_read16(chip_addr, addr, &readback_test);
+        if(Status != XST_SUCCESS) {
+            p_printf(("Couldn't write value 0x%02X to address 0x%04X.\n", val, addr));
+            p_printf(("There were %d successful I2C writes so far.\n", i));
+            return Status;
+        }
+
+        if (val != readback_test) {
+        	p_printf(("address 0x%04X: Write 0x%02X to  and read 0x%02X  ----- Difference detected please check.\r\n",addr, val, readback_test));
+        } else {
+        	p_printf(("address 0x%04X: Write 0x%02X to  and read 0x%02X.\r\n",addr, val, readback_test));
+        }
+      #endif
+    }
+#endif
+
+#ifdef SI5345_REVD_REG_CONFIG_NUM_REGS
+	for (i=0; i<SI5345_REVD_REG_CONFIG_NUM_REGS; ++i) {
+		val = si5345_revd_registers[i].value;
+		addr = si5345_revd_registers[i].address;
+		Status = iic_write16(chip_addr, addr, val);
+		if(Status != 0) {
+			p_printf(("Couldn't write value 0x%02X to address 0x%04X.\n", val, addr));
+			p_printf(("There were %d succesful I2C writes so far.\n", i));
+			return Status;
+		}
+    #ifdef DEBUG_REG
+      Status = iic_read16(chip_addr, addr, &readback_test);
+      if(Status != XST_SUCCESS) {
+          p_printf(("Couldn't write value 0x%02X to address 0x%04X.\n", val, addr));
+          p_printf(("There were %d successful I2C writes so far.\n", i));
+          return Status;
+      }
+
+      if (val != readback_test) {
+        p_printf(("address 0x%04X: Write 0x%02X to  and read 0x%02X  ----- Difference detected please check.\r\n",addr, val, readback_test));
+      } else {
+        p_printf(("address 0x%04X: Write 0x%02X to  and read 0x%02X.\r\n",addr, val, readback_test));
+      }
+    #endif
+	}
+#endif
+	
+    p_printf(("Si534x Init Complete.\r\n"));
+#ifdef NVM_CODE
+    p_printf(("Write this configuration to the Si5345 NVM? (y/N)\r\n"));
+    if(uart_read_char() == 'y'){
+        si534x_write_nvm(chip_addr)
+    }
+#endif
+	return XST_SUCCESS;
+}
+
+#ifdef NVM_CODE
+int si534x_write_nvm(unsigned char chip_addr){
+	#ifndef NVM_REALY
+	#error "To relase NVM write function please define NVM_REALY in te_si534x.h. You do it on your own risk!"
+	#endif
+
+#ifdef NVM_REALY
+	int Status;
+	unsigned char val;
+	unsigned char active_nvm_bank;
+
+    p_printf(("Si534x NVM Programming Start.\r\n"));
+
+    Status = iic_read16(chip_addr, ACTIVE_NVM_BANK, &val);
+    if(Status != XST_SUCCESS){
+    	p_printf(("Error: Si534x Register read failed.\r\n"));
+    	return Status;
+    }
+    active_nvm_bank = val;
+    if(!((active_nvm_bank == 3) | (active_nvm_bank == 15))){
+    	p_printf(("Error: Wrong ACTIVE_NVM_BANK d (should be 3 or 15).\r\n", active_nvm_bank));
+    	return XST_FAILURE;
+    }
+
+    p_printf(("Write NVM_WRITE register.\r\n"));
+    Status = iic_write16(chip_addr, NVM_WRITE, 0xC7);
+    if(Status != XST_SUCCESS){
+    	p_printf(("Error: Si534x Register write failed\r\n"));
+    	return Status;
+    }
+
+    p_printf(("Poll DEVICE_READY.\r\n"));
+    do{
+    	Status = iic_read16(chip_addr, DEVICE_READY, &val);
+    	if(Status != XST_SUCCESS){
+    		p_printf(("Error: Si534x Register read failed\r\n"));
+    		return Status;
+    	}
+    }
+	while(val != 0x0F);
+
+    p_printf(("Load the NVM contents into non-volatile memory.\r\n"));
+    Status = iic_write16(chip_addr, NVM_READ_BANK, 0x01);
+    if(Status != XST_SUCCESS){
+    	p_printf(("Error: Si534x Register write failed\r\n"));
+    	return Status;
+    }
+
+    p_printf(("Poll DEVICE_READY.\r\n"));
+    do {
+    	Status = iic_read16(chip_addr, DEVICE_READY, &val);
+    	if(Status != XST_SUCCESS){
+    		p_printf(("Error: Si534x Register read failed.\r\n"));
+    		return Status;
+    	}
+    }
+    while(val != 0x0F);
+
+    p_printf(("Read ACTIVE_NVM_BANK.\r\n"));
+    Status = iic_read16(chip_addr, ACTIVE_NVM_BANK, &val);
+    if(Status != XST_SUCCESS){
+    	p_printf(("Error: Si534x Register read failed.\r\n"));
+    	return Status;
+    }
+    if(((active_nvm_bank << 2) | 0x03) != val){
+    	p_printf(("Error: Wrong ACTIVE_NVM_BANK %d (was %d next should be %d).\r\n", val, active_nvm_bank, ((active_nvm_bank << 2) | 0x03)));
+    	return XST_FAILURE;
+    }
+
+    p_printf(("Si534x NVM Programming Complete.\r\n"));
+	#endif
+	return XST_SUCCESS;
+}
+#endif
+#endif /*Clock chip*/
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_si534x.h b/lib/sw_apps/zynqmp_fsbl/src/te_si534x.h
new file mode 100644
index 0000000000..4eb4cae7ec
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_si534x.h
@@ -0,0 +1,43 @@
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+#ifndef SI534X_H
+#define SI534X_H
+
+#include "te_iic_platform.h"
+#ifdef CLOCK_SI5345
+
+/* Si5345 default address is 0x69 */
+//#define SI534X_CHIP_ADDR	0x68
+#define SI534X_CHIP_ADDR	0x69
+//#define SI534X_CHIP_ADDR	0x6A
+//#define SI534X_CHIP_ADDR	0x6B
+
+
+/* Registers used for NVM Programming */
+#define ACTIVE_NVM_BANK		0x00E2
+#define NVM_WRITE			0x00E3
+#define NVM_READ_BANK		0x00E4
+#define DEVICE_READY		0x00FE
+
+//enable register read back and printf
+//#define DEBUG_REG	
+
+//max delay for calibration from SI documentation 300ms
+#define TIME_CHECK_PLL_CONFIG_US	0x50000U
+//delay
+#define DELAY_AFTER_PLL_CONFIG_US	0x20000U 
+
+int si534x_version(unsigned char chip_addr);
+int si534x_status_wait(unsigned char chip_addr);
+// #define NVM_CODE
+int si534x_init(unsigned char chip_addr);
+#ifdef NVM_CODE
+int si534x_write_nvm(unsigned char chip_addr);
+// #define NVM_REALY
+#endif
+
+#endif /* CLOCK_SI5345 */
+
+#endif /* SI534X_H */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_uart.c b/lib/sw_apps/zynqmp_fsbl/src/te_uart.c
index 20490eef86..d93472dc5c 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/te_uart.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_uart.c
@@ -1,47 +1,47 @@
-/*
--- Company: 		Trenz Electronic
--- Engineer: 		Oleksandr Kiyenko / John Hartfiel
- */
-#include "te_uart.h"
-
-/*----------------------------------------------------------------------------*/
-#ifdef UART_TYPE_AXI_UARTLITE
-u8 uart_read_char(void){
-	u8 u;
-    XUartLite_Initialize(&UartLite, UART_DEVICE_ID);
-    while(!XUartLite_Recv(&UartLite, &u, 1)){
-    }
-	return u;
-}
-#endif /* UART_TYPE_AXI_UARTLITE */
-/*----------------------------------------------------------------------------*/
-#ifdef UART_TYPE_AXI_UART16550
-u8 uart_read_char(void){
-	u8 u;
-	XUartNs550_Initialize(&UartNs550, UART_DEVICE_ID);
-	XUartNs550_SetBaudRate(&UartNs550, UART_BAUDRATE);
-    while(!XUartNs550_Recv(&UartNs550, &u, 1)){
-    }
-	return u;
-}
-#endif /* UART_TYPE_AXI_UART16550 */
-/*----------------------------------------------------------------------------*/
-#if defined(UART_TYPE_ZYNQPS_UART) || defined(UART_TYPE_ZYNQUPS_UART)
-u8 uart_read_char(void){
-	u8 u;
-	XUartPs_Config *Config;
-	Config = XUartPs_LookupConfig(UART_DEVICE_ID);
-	XUartPs_CfgInitialize(&Uart_Ps, Config, Config->BaseAddress);
-	XUartPs_SetBaudRate(&Uart_Ps, UART_BAUDRATE);
-	while(!XUartPs_Recv(&Uart_Ps, &u, 1)){
-	}
-	return u;
-}
-#endif /* UART_TYPE_ZYNQPS_UART */
-/*----------------------------------------------------------------------------*/
-#ifdef UART_TYPE_NO_UART
-u8 uart_read_char(void){
-	return 0;
-}
-#endif /* UART_TYPE_NO_UART */
-/*----------------------------------------------------------------------------*/
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+#include "te_uart.h"
+
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_AXI_UARTLITE
+u8 uart_read_char(void){
+	u8 u;
+    XUartLite_Initialize(&UartLite, UART_DEVICE_ID);
+    while(!XUartLite_Recv(&UartLite, &u, 1)){
+    }
+	return u;
+}
+#endif /* UART_TYPE_AXI_UARTLITE */
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_AXI_UART16550
+u8 uart_read_char(void){
+	u8 u;
+	XUartNs550_Initialize(&UartNs550, UART_DEVICE_ID);
+	XUartNs550_SetBaudRate(&UartNs550, UART_BAUDRATE);
+    while(!XUartNs550_Recv(&UartNs550, &u, 1)){
+    }
+	return u;
+}
+#endif /* UART_TYPE_AXI_UART16550 */
+/*----------------------------------------------------------------------------*/
+#if defined(UART_TYPE_ZYNQPS_UART) || defined(UART_TYPE_ZYNQUPS_UART)
+u8 uart_read_char(void){
+	u8 u;
+	XUartPs_Config *Config;
+	Config = XUartPs_LookupConfig(UART_DEVICE_ID);
+	XUartPs_CfgInitialize(&Uart_Ps, Config, Config->BaseAddress);
+	XUartPs_SetBaudRate(&Uart_Ps, UART_BAUDRATE);
+	while(!XUartPs_Recv(&Uart_Ps, &u, 1)){
+	}
+	return u;
+}
+#endif /* UART_TYPE_ZYNQPS_UART */
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_NO_UART
+u8 uart_read_char(void){
+	return 0;
+}
+#endif /* UART_TYPE_NO_UART */
+/*----------------------------------------------------------------------------*/
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_uart.h b/lib/sw_apps/zynqmp_fsbl/src/te_uart.h
index 31829fd00e..f6dc11edf1 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/te_uart.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_uart.h
@@ -1,40 +1,40 @@
-/*
--- Company: 		Trenz Electronic
--- Engineer: 		Oleksandr Kiyenko / John Hartfiel
- */
-#ifndef SRC_TE_UART_H_
-#define SRC_TE_UART_H_
-
-#include "te_iic_platform.h"
-
-u8 uart_read_char(void);
-
-/*----------------------------------------------------------------------------*/
-#ifdef UART_TYPE_AXI_UARTLITE
-#include "xil_printf.h"
-#include "xuartlite.h"
-#define p_printf(x)	xil_printf x
-XUartLite UartLite;
-#endif /* UART_TYPE_AXI_UARTLITE */
-/*----------------------------------------------------------------------------*/
-#ifdef UART_TYPE_AXI_UART16550
-#include "xil_printf.h"
-#include "xuartns550.h"
-#include "xuartns550_i.h"
-#define p_printf(x)	xil_printf x
-XUartNs550 UartNs550;
-#endif /* UART_TYPE_AXI_UART16550 */
-/*----------------------------------------------------------------------------*/
-#if defined(UART_TYPE_ZYNQPS_UART) || defined(UART_TYPE_ZYNQUPS_UART)
-#include "xil_printf.h"
-#include "xuartps.h"
-#define p_printf(x)	xil_printf x
-XUartPs Uart_Ps;
-#endif /* UART_TYPE_ZYNQPS_UART */
-/*----------------------------------------------------------------------------*/
-#ifdef UART_TYPE_NO_UART
-#define p_printf(x)
-#endif /* UART_TYPE_NO_UART */
-/*----------------------------------------------------------------------------*/
-
-#endif /* SRC_TE_UART_H_ */
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+#ifndef SRC_TE_UART_H_
+#define SRC_TE_UART_H_
+
+#include "te_iic_platform.h"
+
+u8 uart_read_char(void);
+
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_AXI_UARTLITE
+#include "xil_printf.h"
+#include "xuartlite.h"
+#define p_printf(x)	xil_printf x
+XUartLite UartLite;
+#endif /* UART_TYPE_AXI_UARTLITE */
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_AXI_UART16550
+#include "xil_printf.h"
+#include "xuartns550.h"
+#include "xuartns550_i.h"
+#define p_printf(x)	xil_printf x
+XUartNs550 UartNs550;
+#endif /* UART_TYPE_AXI_UART16550 */
+/*----------------------------------------------------------------------------*/
+#if defined(UART_TYPE_ZYNQPS_UART) || defined(UART_TYPE_ZYNQUPS_UART)
+#include "xil_printf.h"
+#include "xuartps.h"
+#define p_printf(x)	xil_printf x
+XUartPs Uart_Ps;
+#endif /* UART_TYPE_ZYNQPS_UART */
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_NO_UART
+#define p_printf(x)
+#endif /* UART_TYPE_NO_UART */
+/*----------------------------------------------------------------------------*/
+
+#endif /* SRC_TE_UART_H_ */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks.h b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks.h
index cdf46996c3..209318b746 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks.h
@@ -22,7 +22,7 @@ extern "C" {
 #include "xil_types.h"
 #include "xfsbl_hw.h"
 // rename and enable custom TE hooks
-#include "te_xfsbl_hooks_te0803.h"
+#include "te_xfsbl_hooks_te0808.h"
 
 #define ENABLE_TE_HOOKS_PSU //TE_XFsbl_HookPsuInit
 #define ENABLE_TE_BOARD // TE_XFsbl_BoardInit
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.c b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0808.c
similarity index 79%
rename from lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.c
rename to lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0808.c
index 71379660d1..b4f3def665 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0808.c
@@ -13,7 +13,7 @@
 ******************************************************************************/
 /***************************** Include Files *********************************/
 //rename to correct board name
-#include "te_xfsbl_hooks_te0803.h"
+#include "te_xfsbl_hooks_te0808.h"
 
 #include "psu_init.h"
 /************************** Constant Definitions *****************************/
@@ -30,7 +30,7 @@ u32 TE_XFsbl_HookBeforeBSDownload_Custom(void )
 	u32 Status = XFSBL_SUCCESS;
 
     xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
-    xil_printf("TE0803 TE_XFsbl_HookBeforeBSDownload_Custom\r\n"); 
+    xil_printf("TE0808 TE_XFsbl_HookBeforeBSDownload_Custom\r\n"); 
 	/* Add the code here */
     xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
 
@@ -43,7 +43,7 @@ u32 TE_XFsbl_HookAfterBSDownload_Custom(void )
 	u32 Status = XFSBL_SUCCESS;
 
     xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
-    xil_printf("TE0803 TE_XFsbl_HookAfterBSDownload_Custom\r\n"); 
+    xil_printf("TE0808 TE_XFsbl_HookAfterBSDownload_Custom\r\n"); 
 	/* Add the code here */
     xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
 
@@ -55,7 +55,7 @@ u32 TE_XFsbl_HookBeforeHandoff_Custom(u32 EarlyHandoff)
 	u32 Status = XFSBL_SUCCESS;
 
     xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
-    xil_printf("TE0803 TE_XFsbl_HookBeforeHandoff_Custom\r\n"); 
+    xil_printf("TE0808 TE_XFsbl_HookBeforeHandoff_Custom\r\n"); 
 	/* Add the code here */
     xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
 
@@ -79,7 +79,7 @@ u32 TE_XFsbl_HookBeforeFallback_Custom(void)
 
 
   xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
-  xil_printf("TE0803 TE_XFsbl_HookBeforeFallback_Custom\r\n"); 
+  xil_printf("TE0808 TE_XFsbl_HookBeforeFallback_Custom\r\n"); 
 	/* Add the code here */
   xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
 
@@ -120,8 +120,6 @@ u32 TE_XFsbl_HookBeforeFallback_Custom(void)
   psu_status &=   psu_pll_init_data();
   psu_status &=   psu_clock_init_data();
   psu_status &=  psu_ddr_init_data();
-  
-
   // modified to use same code for DDR with and without self refresh mode, diff between  psu_init_ddr_self_refresh and psu_init
   if (DDRRegVal) {
     //do nothing
@@ -136,37 +134,36 @@ u32 TE_XFsbl_HookBeforeFallback_Custom(void)
     // exit on error
     goto END;
   }
-
-  
   //add code to initialize SI on module for GTR periphery
   xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
-  xil_printf("TE0803 TE_XFsbl_HookPsuInit_Custom\r\n"); 
+  xil_printf("TE0808 TE_XFsbl_HookPsuInit_Custom\r\n"); 
   /* Add the code here */
   // ------------------------------------------------------
   // reset PCI and USB
   	u32 dataVal = 0;
+    u32 conVal = 0;
 
     // USB reset  
-		/* Set MIO28 direction as output */
-    XFsbl_Out32(GPIO_DIRM_1, XFsbl_In32(GPIO_DIRM_1) | GPIO_MIO28_MASK);
+		/* Set MIO40 direction as output */
+    XFsbl_Out32(GPIO_DIRM_1, XFsbl_In32(GPIO_DIRM_1) | GPIO_MIO40_MASK);
 
-		/* Set MIO28 output enable */
-    XFsbl_Out32(GPIO_OEN_1, XFsbl_In32(GPIO_OEN_1) | GPIO_MIO28_MASK);  
+		/* Set MIO40 output enable */
+    XFsbl_Out32(GPIO_OEN_1, XFsbl_In32(GPIO_OEN_1) | GPIO_MIO40_MASK);  
     
-    /* Set MIO28 to LOW */
-		dataVal = XFsbl_In32(GPIO_DATA_1) & ~(GPIO_MIO28_MASK);
+    /* Set MIO40 to LOW */
+		dataVal = XFsbl_In32(GPIO_DATA_1) & ~(GPIO_MIO40_MASK);
 		XFsbl_Out32(GPIO_DATA_1, dataVal);
     
     // pcie reset
-    /* Set MIO34 direction as output */
-    XFsbl_Out32(GPIO_DIRM_1, XFsbl_In32(GPIO_DIRM_1) | GPIO_MIO34_MASK);
+    /* Set MIO41 direction as output */
+    XFsbl_Out32(GPIO_DIRM_1, XFsbl_In32(GPIO_DIRM_1) | GPIO_MIO41_MASK);
 
-    /* Set MIO34 output enable */
-    XFsbl_Out32(GPIO_OEN_1, XFsbl_In32(GPIO_OEN_1) | GPIO_MIO34_MASK);
+    /* Set MIO41 output enable */
+    XFsbl_Out32(GPIO_OEN_1, XFsbl_In32(GPIO_OEN_1) | GPIO_MIO41_MASK);
 
 
-    /* Set MIO34 to LOW */
-    dataVal = XFsbl_In32(GPIO_DATA_1) & ~(GPIO_MIO34_MASK);
+    /* Set MIO41 to LOW */
+    dataVal = XFsbl_In32(GPIO_DATA_1) & ~(GPIO_MIO41_MASK);
     XFsbl_Out32(GPIO_DATA_1, dataVal);
 
   // ------------------------------------------------------
@@ -175,53 +172,77 @@ u32 TE_XFsbl_HookBeforeFallback_Custom(void)
      xil_printf("Error:I2C Init\r\n");
      goto END;
   }
-  // change I2C switch to get access to SI5345
- // xil_printf("Configure Carrier I2C Switch 0x77\r\n");
- // Status = iic_write8(0x77, 0x00,  0x10);    // Configure I2C Switch
- // if (Status != XFSBL_SUCCESS) {
- //    xil_printf("Error: Configure TEBF0808 I2C Switch 0x77 for TE0803 SI5338 access\r\n");
- //    goto END;
+  
+  Status = iic1_init();                      // Configure I2C Bus 1 driver instance
+  if (Status != XFSBL_SUCCESS) {
+      xil_printf("Error:I2C 1 Init\r\n");
+      goto END;
+  }
+  // change I2C switch to get access to PLL
+  //xil_printf("Configure Carrier I2C Switch 0x77\r\n");
+  //Status = iic_write8(0x77, 0x00,  0x10);    // Configure I2C Switch
+  //if (Status != XFSBL_SUCCESS) {
+  //   xil_printf("Error: Configure TEBF0808 I2C Switch 0x77 for TE0808 PLL access\r\n");
+  //   goto END;
  // }
   
   xil_printf("Configure PLL: ");
 
-  Status= si5338_version(0x70);
+  Status= si534x_version(0x69);
   if (Status != XFSBL_SUCCESS) {
      xil_printf("Error: Read Version of PLL\r\n");
      goto END;
   }
-  
-  Status = si5338_init(0x70);                      // Configure clocks
+
+  Status = si534x_init(0x69);                      // Configure clocks
   if (Status != XFSBL_SUCCESS) {
-     xil_printf("Error: Configure CLK\r\n");
+     xil_printf("Error: Configure PLL CLK\r\n");
      goto END;
   }
-  Status= si5338_status_wait(0x70);
+  
+  xil_printf("Configure DS102: ");
+  Status = DS80PCI102_init(0x59);
+  if (Status != XFSBL_SUCCESS) {
+      xil_printf("Error: Configure DS80PCI102 \r\n");
+      
+  }
+  
+  xil_printf("Configure DS800: ");
+  Status = DS80PCI800_init(0x58);
+  if (Status != XFSBL_SUCCESS) {
+      xil_printf("Error: Configure DS80PCI800 \r\n");
+      
+  }
+  
+ 
+  Status= si534x_status_wait(0x69);
   if (Status != XFSBL_SUCCESS) {
      xil_printf("Error: Read Status of PLL and wait for calibration\r\n");
      goto END;
   }
-  
+
   // ------------------------------------------------------
   // release PCI and USB reset
-  /* Set MIO28 to HIGH */
-  dataVal = XFsbl_In32(GPIO_DATA_1) | GPIO_MIO28_MASK;
-  XFsbl_Out32(GPIO_DATA_1, dataVal);
-  xil_printf("USB Reset Complete \r\n");
-  
-
-  /* Set MIO34 to HIGH */
-  dataVal = XFsbl_In32(GPIO_DATA_1) | GPIO_MIO34_MASK;
-  XFsbl_Out32(GPIO_DATA_1, dataVal);
-  xil_printf("PCIe Reset Complete\r\n");
+    /* Set MIO40 to HIGH */
+		dataVal = XFsbl_In32(GPIO_DATA_1) | GPIO_MIO40_MASK;
+		XFsbl_Out32(GPIO_DATA_1, dataVal);
+    xil_printf("USB Reset Complete \r\n");
+    
+		/* Set MIO41 to HIGH */
+		dataVal = XFsbl_In32(GPIO_DATA_1) | GPIO_MIO41_MASK;
+		XFsbl_Out32(GPIO_DATA_1, dataVal);
+    xil_printf("PCIe Reset Complete\r\n");
 
   // ------------------------------------------------------
   xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
   /* wait after initialization*/
   (void)usleep(DELAY_5_US);
   
+  
+  /* -------------------------------------- */
+  
   //note: SDK with default FSBL will not generate init_serdes(), when no serdes are available
-#if defined(SERDES_PLL_REF_SEL0_PLLREFSEL0_DEFVAL) || defined(SERDES_PLL_REF_SEL1_PLLREFSEL1_DEFVAL) || defined(SERDES_PLL_REF_SEL2_PLLREFSEL2_DEFVAL)  ||  defined(SERDES_PLL_REF_SEL3_PLLREFSEL3_DEFVAL)
+#if defined(SERDES_PLL_REF_SEL0_PLLREFSEL0_DEFVAL) || defined(SERDES_PLL_REF_SEL1_PLLREFSEL1_DEFVAL) || defined(SERDES_PLL_REF_SEL2_PLLREFSEL2_DEFVAL)  ||  defined(SERDES_PLL_REF_SEL3_PLLREFSEL3_DEFVAL)  
   //psu_status &=  init_serdes();  --> replace with inner code
     // code from init_serdes():
     psu_status &=  psu_resetin_init_data();
@@ -256,7 +277,7 @@ u32 TE_XFsbl_HookBeforeFallback_Custom(void)
   psu_status &=    psu_afi_config();
   psu_ddr_qos_init_data();
 
-// code from psu_init():
+  // code from psu_init():
   if (psu_status == 0) {
     Status= psu_status;
     // exit on error
@@ -293,7 +314,7 @@ u32 TE_XFsbl_XPSU_Default(void)
   	return Status;
 }
 #endif
-  
+
 u32 TE_XFsbl_HookPsuInit_Custom(void)
 {
 	u32 Status = XFSBL_SUCCESS;
@@ -306,14 +327,13 @@ u32 TE_XFsbl_HookPsuInit_Custom(void)
 
 	return Status;
 }
-  
+
 
 /*****************************************************************************/
 /**
   * for xsfbl_board.h
   *****************************************************************************/
 
-
 /*****************************************************************************/
 /**
  * This function does board specific initialization.
@@ -334,16 +354,16 @@ u32 TE_XFsbl_BoardInit_Custom(void)
   u32 RegVal = 0;
   u32 temp = 0;
   xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
-  xil_printf("TE0803 TE_XFsbl_BoardInit_Custom\r\n");
+  xil_printf("TE0808 TE_XFsbl_BoardInit_Custom\r\n");
 	// /* Add the code here */
-
+  
   //check USB,PCIe Reset
   RegVal = XFsbl_In32(GPIO_DATA_1) ;
-  temp = ((RegVal) & (GPIO_MIO28_MASK))>>4;
+  temp = ((RegVal) & (GPIO_MIO40_MASK))>>4;
   if (temp!=0x1) {
     xil_printf("USB is hold into reset. (GPIO_DATA_1, Val:%x)\r\n", RegVal);
   }
-  temp = ((RegVal) & (GPIO_MIO34_MASK))>>5;
+  temp = ((RegVal) & (GPIO_MIO41_MASK))>>5;
   if (temp!=0x1) {
     xil_printf("PCIe is hold into reset. (GPIO_DATA_1, Val:%x)\r\n", RegVal);
   }
@@ -377,16 +397,15 @@ u32 TE_XFsbl_BoardInit_Custom(void)
   }
 #endif
   
-  #ifdef USE_TE_PSU_FOR_SI_INIT
+#ifdef USE_TE_PSU_FOR_SI_INIT
 
-  #else
-    Status = iic_init();                      // Configure I2C Bus 0 driver instance
-    if (Status != XFSBL_SUCCESS) {
-       xil_printf("Error:I2C Init\r\n");
-       goto END;
-    }
-  #endif
-  
+#else
+  Status = iic_init();                      // Configure I2C Bus 0 driver instance
+  if (Status != XFSBL_SUCCESS) {
+     xil_printf("Error:I2C Init\r\n");
+     goto END;
+  }
+#endif
   // change I2C switch to get access to EEPROM 
   //xil_printf("Configure Carrier I2C Switch 0x73 for EEPROM access\r\n");
   //Status = iic_write8(0x73, 0x00,  0x20);    // Configure I2C Switch
@@ -395,6 +414,8 @@ u32 TE_XFsbl_BoardInit_Custom(void)
   //   goto END;
  // }
   
+  
+  
   xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
 
   END:
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.h b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0808.h
similarity index 88%
rename from lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.h
rename to lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0808.h
index 25b4dd78d9..5da15ebfda 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0808.h
@@ -13,8 +13,8 @@
 *
 ******************************************************************************/
 //rename to correct board name
-#ifndef TE_XFSBL_HOOKS_TE0803_H
-#define TE_XFSBL_HOOKS_TE0803_H
+#ifndef TE_XFSBL_HOOKS_TE0808_H
+#define TE_XFSBL_HOOKS_TE0808_H
 
 #ifdef __cplusplus
 extern "C" {
@@ -25,14 +25,15 @@ extern "C" {
 #include "xfsbl_hw.h"
 
 #include "te_iic_platform.h"
-#include "te_si5338.h"
+#include "te_si534x.h"
 #include "xparameters.h"
 /************************** Constant Definitions *****************************/
 #define USE_TE_PSU_FOR_SI_INIT //enable TE PSU to write SI on the correct place in the FSBL (Xilinx default PSU is deactivated)
 
-
-#define GPIO_MIO34_MASK	0x00000100U
-#define GPIO_MIO28_MASK	0x00000004U
+#define GPIO_MIO41_MASK 0x00008000U
+#define GPIO_MIO40_MASK 0x00004000U
+//#define GPIO_MIO34_MASK	0x00000100U
+//#define GPIO_MIO28_MASK	0x00000004U
 #define ICM_CFG_VAL_PCIE	0X1U
 #define DELAY_1_US			0x1U
 #define DELAY_5_US			0x5U
